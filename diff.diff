diff --git a/game/game.c b/game/game.c
index a22b551..fc80f6f 100755
--- a/game/game.c
+++ b/game/game.c
@@ -118,10 +118,11 @@ bool check_win() {
 }
 
 int main() {
+
 	sys_timer(timer_event);
 	sys_keyboard(keyboard_event);
     // sys_sleep(0x1000);
-
+	// sys_exit();
     printk("game start! SYS_pid = %d\n", sys_getpid());
 
     main_loop();
diff --git a/game/syscall.c b/game/syscall.c
index c0b8496..0765b45 100644
--- a/game/syscall.c
+++ b/game/syscall.c
@@ -101,6 +101,12 @@ __attribute__((noreturn)) void sys_crash() {
 void sys_wait_intr(){
     do_syscall0(SYS_wait_intr);
 }
+
+__attribute__((noreturn))
+void sys_exit() {
+    do_syscall0(SYS_exit);
+    sys_crash();
+}
 void sys_sleep(uint32_t time) {
     my_assert(do_syscall1(SYS_sleep, time) == 0);
 }
diff --git a/inc/pcb.h b/inc/pcb.h
index 06e30ed..6a08cd3 100644
--- a/inc/pcb.h
+++ b/inc/pcb.h
@@ -45,7 +45,9 @@ uint32_t get_pid();
 
 void pcb_init();
 
+void pcb_exit();
+
 void pcb_enter(struct PCB *pcb, uintptr_t esp, uintptr_t eip, uint32_t eflags);
 
-void pcb_exec(struct PCB *pcb);
+void pcb_exec(struct PCB* pcb);
 #endif //OSLAB_PCB_H
diff --git a/inc/sched.h b/inc/sched.h
index 1e0d41a..128b69b 100644
--- a/inc/sched.h
+++ b/inc/sched.h
@@ -5,4 +5,6 @@
 #ifndef OSLAB_SCHED_H
 #define OSLAB_SCHED_H
 
+void sched_process();
+
 #endif //OSLAB_SCHED_H
diff --git a/inc/syscall.h b/inc/syscall.h
index 64712a0..5c29cf2 100755
--- a/inc/syscall.h
+++ b/inc/syscall.h
@@ -7,15 +7,17 @@
 #define HZ 100
 
 enum {
-    SYS_vprintk = 0,
-    SYS_timer,
-    SYS_keyboard,
-    SYS_display,
     SYS_crash,
+    SYS_display,
+    SYS_exit,
+    SYS_fork,
+    SYS_getpid,
+    SYS_keyboard,
     SYS_sleep,
+    SYS_timer,
+    SYS_vprintk,
     SYS_wait_intr,
-    SYS_getpid,
-    SYS_fork,
+
 };
 
 void sys_vprintk(const char *ctl, va_list arg);
@@ -26,6 +28,8 @@ void sys_display(uint8_t *buffer);
 void sys_crash() __attribute__((noreturn));
 void sys_sleep(uint32_t time);
 
+void sys_exit() __attribute__((noreturn));
+
 void sys_wait_intr();
 
 int sys_getpid();
diff --git a/kernel/init.c b/kernel/init.c
index 7d7c97d..06564ba 100755
--- a/kernel/init.c
+++ b/kernel/init.c
@@ -29,7 +29,6 @@ uintptr_t userprog_load(uint32_t offset) {
 	load_updir(get_pid());
 	for (int phnum = elfheader->e_phnum; phnum > 0; --phnum, ++ph)
 		if (ph->p_type == 1) { // ELF_PROG_LOAD
-			printk("%s: ph->p_pa = %x\n", __func__, ph->p_pa);
 			my_assert(ph->p_pa >= 0x1000000);         // don't overlap kernel
 			ide_read((void *) ph->p_pa, offset + ph->p_offset, ph->p_filesz);
 			memset((void *) (ph->p_pa + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
diff --git a/kernel/pcb.c b/kernel/pcb.c
index 49890c1..c50d82f 100644
--- a/kernel/pcb.c
+++ b/kernel/pcb.c
@@ -3,6 +3,7 @@
 #include "string.h"
 #include <inc/pcb.h>
 #include <inc/pmap.h>
+#include <inc/sched.h>
 
 
 static uint32_t curr_pid;
@@ -33,17 +34,27 @@ void pcb_enter(struct PCB *pcb, uintptr_t esp, uintptr_t eip, uint32_t eflags) {
     pcb->tf.tf_eflags = eflags;
 }
 
-void pcb_exec(struct PCB *pcb) {
-    // TODO: lcr3
-    pcb->status = PCB_FREE;
+
+void pcb_exit() {
+    user_pcbs[curr_pid].status = PCB_FREE;
+    // sched_process();
+}
+
+
+void pcb_exec(struct PCB* pcb) { // exec a new process
+    // user_pcbs[pid].status = PCB_RUNNING;
+    // load_updir(curr_pid = pid);
+    // TODO: test it
+    printk("%s: \n", __func__);
     __asm __volatile("movl %0,%%esp\n"
             "\tpopal\n"
             "\tpopl %%es\n"
             "\tpopl %%ds\n"
             "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
             "\tiret"
-    : : "g" (&pcb->tf) : "memory");
-    panic("iret failed");  /* mostly to placate the compiler */
+    : : "g" (pcb->tf) : "memory");
+
+    panic("iret failed");
 }
 
 
diff --git a/kernel/sched.c b/kernel/sched.c
index bfa46fa..9465d0d 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -1 +1,16 @@
+
+#include <inc/pcb.h>
 #include "inc/sched.h"
+
+__attribute__((noreturn))
+void sched_process(){ // change to another process
+    printk("Scheduling processes\n");
+    my_assert(user_pcbs[get_pid()].status != PCB_RUNNING);
+    for(int i = 0; i < UPCB_NUM; i++) {
+        if(i == get_pid()) continue;
+        if(user_pcbs[i].status == PCB_RUNNABLE)
+            // pcb_exec(i); // no return
+            panic(""); // TODO: implement this
+    }
+    panic("No runnable process");
+}
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index aaa5ebb..018ff62 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -5,6 +5,7 @@
 #include <inc/cpu.h>
 #include <inc/memlayout.h>
 #include <inc/pcb.h>
+#include <inc/sched.h>
 #include "trap.h"
 
 void sys_vprintk(const char *ctl, va_list arg) {
@@ -13,6 +14,12 @@ void sys_vprintk(const char *ctl, va_list arg) {
     vfprintf(serial_printc, ctl, arg);
 }
 
+__attribute__((noreturn))
+void sys_exit() {
+    pcb_exit();
+    panic("");
+}
+
 void sys_timer(void (*handler)(void)) {
     do_timer = handler;
 }
@@ -26,8 +33,11 @@ void sys_display(uint8_t *buffer) {
 }
 
 void sys_sleep(uint32_t time) {
+
     user_pcbs[get_pid()].status = PCB_SLEEPING;
     user_pcbs[get_pid()].wakeup_time = time;
+    // sched_process();
+    panic("Return failed");
 }
 
 void sys_wait_intr() {
@@ -47,11 +57,14 @@ uint32_t syscall_handler(struct Trapframe *tf) {
 #define arg4 tf->tf_regs.reg_edi
 #define arg5 tf->tf_regs.reg_esi
     switch (tf->tf_regs.reg_eax) {  // syscall number
+        case SYS_exit:
+            sys_exit();
         case SYS_vprintk:
             sys_vprintk((const char *) arg1, (va_list) arg2);
             return 0;
         case SYS_timer:
             sys_timer((void (*)(void)) arg1);
+            // sched_process();
             return 0;
         case SYS_keyboard:
             sys_keyboard((void (*)(int)) arg1);
