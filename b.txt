
kernel.bin.bak:     file format elf32-i386


Disassembly of section .text:

f0100000 <wait_for_interrupt>:
#define __X86_CPU_H__

#include "common.h"

static inline void
wait_for_interrupt() {
f0100000:	55                   	push   %ebp
f0100001:	89 e5                	mov    %esp,%ebp
	asm volatile("hlt");
f0100003:	f4                   	hlt    
}
f0100004:	90                   	nop
f0100005:	5d                   	pop    %ebp
f0100006:	c3                   	ret    

f0100007 <disable_interrupt>:
enable_interrupt(void) {
	asm volatile("sti");
}

static inline void
disable_interrupt(void) {
f0100007:	55                   	push   %ebp
f0100008:	89 e5                	mov    %esp,%ebp
	asm volatile("cli");
f010000a:	fa                   	cli    
}
f010000b:	90                   	nop
f010000c:	5d                   	pop    %ebp
f010000d:	c3                   	ret    

f010000e <abort>:
#include <inc/common.h>
#include <inc/x86.h>

int
abort(const char *fname, int line) {
f010000e:	55                   	push   %ebp
f010000f:	89 e5                	mov    %esp,%ebp
f0100011:	83 ec 08             	sub    $0x8,%esp
	/* disable intr to avoid other errors 
		Display error info and stay awaiting */
	disable_interrupt();
f0100014:	e8 ee ff ff ff       	call   f0100007 <disable_interrupt>
	printk("%s:%d: Assertion failed.\n", fname, line);
f0100019:	83 ec 04             	sub    $0x4,%esp
f010001c:	ff 75 0c             	pushl  0xc(%ebp)
f010001f:	ff 75 08             	pushl  0x8(%ebp)
f0100022:	68 e4 1d 10 f0       	push   $0xf0101de4
f0100027:	e8 e9 08 00 00       	call   f0100915 <printk>
f010002c:	83 c4 10             	add    $0x10,%esp
	while (TRUE) {
		wait_for_interrupt();
f010002f:	e8 cc ff ff ff       	call   f0100000 <wait_for_interrupt>
	}
f0100034:	eb f9                	jmp    f010002f <abort+0x21>

f0100036 <ide_wait_ready>:
#define IDE_DF		0x20
#define IDE_ERR		0x01

static int
ide_wait_ready(bool check_error)
{
f0100036:	55                   	push   %ebp
f0100037:	89 e5                	mov    %esp,%ebp
f0100039:	83 ec 14             	sub    $0x14,%esp
f010003c:	8b 45 08             	mov    0x8(%ebp),%eax
f010003f:	88 45 ec             	mov    %al,-0x14(%ebp)
    int r;

    while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0100042:	90                   	nop
f0100043:	c7 45 f8 f7 01 00 00 	movl   $0x1f7,-0x8(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010004a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010004d:	89 c2                	mov    %eax,%edx
f010004f:	ec                   	in     (%dx),%al
f0100050:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100053:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0100057:	0f b6 c0             	movzbl %al,%eax
f010005a:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010005d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100060:	25 c0 00 00 00       	and    $0xc0,%eax
f0100065:	83 f8 40             	cmp    $0x40,%eax
f0100068:	75 d9                	jne    f0100043 <ide_wait_ready+0xd>
        /* do nothing */;

    if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f010006a:	80 7d ec 00          	cmpb   $0x0,-0x14(%ebp)
f010006e:	74 11                	je     f0100081 <ide_wait_ready+0x4b>
f0100070:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100073:	83 e0 21             	and    $0x21,%eax
f0100076:	85 c0                	test   %eax,%eax
f0100078:	74 07                	je     f0100081 <ide_wait_ready+0x4b>
        return -1;
f010007a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010007f:	eb 05                	jmp    f0100086 <ide_wait_ready+0x50>
    return 0;
f0100081:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100086:	c9                   	leave  
f0100087:	c3                   	ret    

f0100088 <ide_read>:

_Static_assert(!(SECTSIZE & (SECTSIZE - 1)), "SECTSIZE must be a power of 2!");
int ide_read(void *dst, uint32_t offset, uint32_t count) {
f0100088:	55                   	push   %ebp
f0100089:	89 e5                	mov    %esp,%ebp
f010008b:	57                   	push   %edi
f010008c:	53                   	push   %ebx
f010008d:	83 ec 50             	sub    $0x50,%esp
    my_assert(!(offset & 3));  // assert: aligned at 4 byte
f0100090:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100093:	83 e0 03             	and    $0x3,%eax
f0100096:	85 c0                	test   %eax,%eax
f0100098:	74 16                	je     f01000b0 <ide_read+0x28>
f010009a:	68 00 1e 10 f0       	push   $0xf0101e00
f010009f:	68 0e 1e 10 f0       	push   $0xf0101e0e
f01000a4:	6a 19                	push   $0x19
f01000a6:	68 23 1e 10 f0       	push   $0xf0101e23
f01000ab:	e8 ea 1c 00 00       	call   f0101d9a <_panic>
    my_assert(!(count & 3));
f01000b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01000b3:	83 e0 03             	and    $0x3,%eax
f01000b6:	85 c0                	test   %eax,%eax
f01000b8:	74 16                	je     f01000d0 <ide_read+0x48>
f01000ba:	68 30 1e 10 f0       	push   $0xf0101e30
f01000bf:	68 0e 1e 10 f0       	push   $0xf0101e0e
f01000c4:	6a 1a                	push   $0x1a
f01000c6:	68 23 1e 10 f0       	push   $0xf0101e23
f01000cb:	e8 ca 1c 00 00       	call   f0101d9a <_panic>

    for (uint32_t i = offset & -SECTSIZE, end = offset + count; i < end;) {
f01000d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01000d3:	25 00 fe ff ff       	and    $0xfffffe00,%eax
f01000d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01000db:	8b 55 0c             	mov    0xc(%ebp),%edx
f01000de:	8b 45 10             	mov    0x10(%ebp),%eax
f01000e1:	01 d0                	add    %edx,%eax
f01000e3:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01000e6:	e9 80 01 00 00       	jmp    f010026b <ide_read+0x1e3>
        int r;
        ide_wait_ready(false);
f01000eb:	83 ec 0c             	sub    $0xc,%esp
f01000ee:	6a 00                	push   $0x0
f01000f0:	e8 41 ff ff ff       	call   f0100036 <ide_wait_ready>
f01000f5:	83 c4 10             	add    $0x10,%esp
        uint32_t secno = i / SECTSIZE;
f01000f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01000fb:	c1 e8 09             	shr    $0x9,%eax
f01000fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0100101:	c7 45 dc f2 01 00 00 	movl   $0x1f2,-0x24(%ebp)
f0100108:	c6 45 ba 01          	movb   $0x1,-0x46(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f010010c:	0f b6 45 ba          	movzbl -0x46(%ebp),%eax
f0100110:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100113:	ee                   	out    %al,(%dx)
        outb(0x1F2, 1);
        outb(0x1F3, (uint8_t) secno);
f0100114:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100117:	0f b6 c0             	movzbl %al,%eax
f010011a:	c7 45 d8 f3 01 00 00 	movl   $0x1f3,-0x28(%ebp)
f0100121:	88 45 bb             	mov    %al,-0x45(%ebp)
f0100124:	0f b6 45 bb          	movzbl -0x45(%ebp),%eax
f0100128:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010012b:	ee                   	out    %al,(%dx)
        outb(0x1F4, (uint8_t) (secno >> 8));
f010012c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010012f:	c1 e8 08             	shr    $0x8,%eax
f0100132:	0f b6 c0             	movzbl %al,%eax
f0100135:	c7 45 d4 f4 01 00 00 	movl   $0x1f4,-0x2c(%ebp)
f010013c:	88 45 bc             	mov    %al,-0x44(%ebp)
f010013f:	0f b6 45 bc          	movzbl -0x44(%ebp),%eax
f0100143:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0100146:	ee                   	out    %al,(%dx)
        outb(0x1F5, (uint8_t) (secno >> 16));
f0100147:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010014a:	c1 e8 10             	shr    $0x10,%eax
f010014d:	0f b6 c0             	movzbl %al,%eax
f0100150:	c7 45 d0 f5 01 00 00 	movl   $0x1f5,-0x30(%ebp)
f0100157:	88 45 bd             	mov    %al,-0x43(%ebp)
f010015a:	0f b6 45 bd          	movzbl -0x43(%ebp),%eax
f010015e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0100161:	ee                   	out    %al,(%dx)
        outb(0x1F6, (uint8_t) (0xE0 | (secno >> 24)));
f0100162:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100165:	c1 e8 18             	shr    $0x18,%eax
f0100168:	83 c8 e0             	or     $0xffffffe0,%eax
f010016b:	0f b6 c0             	movzbl %al,%eax
f010016e:	c7 45 cc f6 01 00 00 	movl   $0x1f6,-0x34(%ebp)
f0100175:	88 45 be             	mov    %al,-0x42(%ebp)
f0100178:	0f b6 45 be          	movzbl -0x42(%ebp),%eax
f010017c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010017f:	ee                   	out    %al,(%dx)
f0100180:	c7 45 c0 f7 01 00 00 	movl   $0x1f7,-0x40(%ebp)
f0100187:	c6 45 bf 20          	movb   $0x20,-0x41(%ebp)
f010018b:	0f b6 45 bf          	movzbl -0x41(%ebp),%eax
f010018f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0100192:	ee                   	out    %al,(%dx)
        outb(0x1F7, 0x20);	// CMD 0x20 means read sector
        if ((r = ide_wait_ready(1)) < 0) {
f0100193:	83 ec 0c             	sub    $0xc,%esp
f0100196:	6a 01                	push   $0x1
f0100198:	e8 99 fe ff ff       	call   f0100036 <ide_wait_ready>
f010019d:	83 c4 10             	add    $0x10,%esp
f01001a0:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01001a3:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01001a7:	79 14                	jns    f01001bd <ide_read+0x135>
            panic("(r & (IDE_DF|IDE_ERR)) != 0 r = %d", r);
f01001a9:	ff 75 c8             	pushl  -0x38(%ebp)
f01001ac:	68 40 1e 10 f0       	push   $0xf0101e40
f01001b1:	6a 27                	push   $0x27
f01001b3:	68 23 1e 10 f0       	push   $0xf0101e23
f01001b8:	e8 dd 1b 00 00       	call   f0101d9a <_panic>
        }
        int32_t n = offset - i;
f01001bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01001c0:	2b 45 f4             	sub    -0xc(%ebp),%eax
f01001c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (n > 0) {
f01001c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01001ca:	7e 38                	jle    f0100204 <ide_read+0x17c>
            for (uint32_t j = 0; j < n; j += 4) inl(0x1F0); // seek
f01001cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01001d3:	eb 14                	jmp    f01001e9 <ide_read+0x161>
f01001d5:	c7 45 e0 f0 01 00 00 	movl   $0x1f0,-0x20(%ebp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
f01001dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01001df:	89 c2                	mov    %eax,%edx
f01001e1:	ed                   	in     (%dx),%eax
f01001e2:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f01001e5:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
f01001e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01001ec:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01001ef:	72 e4                	jb     f01001d5 <ide_read+0x14d>
            i += n;
f01001f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01001f4:	01 45 f4             	add    %eax,-0xc(%ebp)
            n = SECTSIZE - n;
f01001f7:	b8 00 02 00 00       	mov    $0x200,%eax
f01001fc:	2b 45 f0             	sub    -0x10(%ebp),%eax
f01001ff:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100202:	eb 07                	jmp    f010020b <ide_read+0x183>
        } else n = SECTSIZE;
f0100204:	c7 45 f0 00 02 00 00 	movl   $0x200,-0x10(%ebp)
        if (n > end - i) n = end - i;
f010020b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010020e:	2b 45 f4             	sub    -0xc(%ebp),%eax
f0100211:	89 c2                	mov    %eax,%edx
f0100213:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100216:	39 c2                	cmp    %eax,%edx
f0100218:	73 09                	jae    f0100223 <ide_read+0x19b>
f010021a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010021d:	2b 45 f4             	sub    -0xc(%ebp),%eax
f0100220:	89 45 f0             	mov    %eax,-0x10(%ebp)
        insl(0x1F0, dst, n / 4);
f0100223:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100226:	8d 50 03             	lea    0x3(%eax),%edx
f0100229:	85 c0                	test   %eax,%eax
f010022b:	0f 48 c2             	cmovs  %edx,%eax
f010022e:	c1 f8 02             	sar    $0x2,%eax
f0100231:	89 c2                	mov    %eax,%edx
f0100233:	c7 45 c4 f0 01 00 00 	movl   $0x1f0,-0x3c(%ebp)
f010023a:	8b 45 08             	mov    0x8(%ebp),%eax
f010023d:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0100240:	89 55 ac             	mov    %edx,-0x54(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0100243:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0100246:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0100249:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010024c:	89 cb                	mov    %ecx,%ebx
f010024e:	89 df                	mov    %ebx,%edi
f0100250:	89 c1                	mov    %eax,%ecx
f0100252:	fc                   	cld    
f0100253:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0100255:	89 c8                	mov    %ecx,%eax
f0100257:	89 fb                	mov    %edi,%ebx
f0100259:	89 5d b0             	mov    %ebx,-0x50(%ebp)
f010025c:	89 45 ac             	mov    %eax,-0x54(%ebp)
        i += n;
f010025f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100262:	01 45 f4             	add    %eax,-0xc(%ebp)
        dst += n;
f0100265:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100268:	01 45 08             	add    %eax,0x8(%ebp)
_Static_assert(!(SECTSIZE & (SECTSIZE - 1)), "SECTSIZE must be a power of 2!");
int ide_read(void *dst, uint32_t offset, uint32_t count) {
    my_assert(!(offset & 3));  // assert: aligned at 4 byte
    my_assert(!(count & 3));

    for (uint32_t i = offset & -SECTSIZE, end = offset + count; i < end;) {
f010026b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010026e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0100271:	0f 82 74 fe ff ff    	jb     f01000eb <ide_read+0x63>
        if (n > end - i) n = end - i;
        insl(0x1F0, dst, n / 4);
        i += n;
        dst += n;
    }
    return 0;
f0100277:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010027c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010027f:	5b                   	pop    %ebx
f0100280:	5f                   	pop    %edi
f0100281:	5d                   	pop    %ebp
f0100282:	c3                   	ret    

f0100283 <load_updir>:

extern size_t npages;
extern struct PageInfo *pages;
extern pte_t user_pgdir[UPDIR_NUM][NPDENTRIES];

static inline void load_updir(int pid) {
f0100283:	55                   	push   %ebp
f0100284:	89 e5                	mov    %esp,%ebp
f0100286:	83 ec 10             	sub    $0x10,%esp
    uint32_t dir_addr = ((uint32_t)user_pgdir[pid]) - KERNBASE;
f0100289:	8b 45 08             	mov    0x8(%ebp),%eax
f010028c:	c1 e0 0c             	shl    $0xc,%eax
f010028f:	05 00 e0 16 f0       	add    $0xf016e000,%eax
f0100294:	05 00 00 00 10       	add    $0x10000000,%eax
f0100299:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010029c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010029f:	89 45 f8             	mov    %eax,-0x8(%ebp)
}

static __inline void
lcr3(uint32_t val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01002a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01002a5:	0f 22 d8             	mov    %eax,%cr3
    // lcr3((uint32_t)entry_pgdir - KERNBASE);
    lcr3(dir_addr);
}
f01002a8:	90                   	nop
f01002a9:	c9                   	leave  
f01002aa:	c3                   	ret    

f01002ab <userprog_load>:

#define SECTCOUNT 1
#define USER_START 0x8048000

uintptr_t userprog_load(uint32_t offset) {
	printk("Loading...%s\n", __func__);
f01002ab:	55                   	push   %ebp
f01002ac:	89 e5                	mov    %esp,%ebp
f01002ae:	81 ec 18 02 00 00    	sub    $0x218,%esp
	uint8_t header[SECTSIZE * SECTCOUNT];
f01002b4:	83 ec 08             	sub    $0x8,%esp
f01002b7:	68 4c 1f 10 f0       	push   $0xf0101f4c
f01002bc:	68 64 1e 10 f0       	push   $0xf0101e64
f01002c1:	e8 4f 06 00 00       	call   f0100915 <printk>
f01002c6:	83 c4 10             	add    $0x10,%esp
	ide_read(header, offset, SECTSIZE * SECTCOUNT);
	struct Elf *elfheader = (struct Elf *) header;
f01002c9:	83 ec 04             	sub    $0x4,%esp
f01002cc:	68 00 02 00 00       	push   $0x200
f01002d1:	ff 75 08             	pushl  0x8(%ebp)
f01002d4:	8d 85 ec fd ff ff    	lea    -0x214(%ebp),%eax
f01002da:	50                   	push   %eax
f01002db:	e8 a8 fd ff ff       	call   f0100088 <ide_read>
f01002e0:	83 c4 10             	add    $0x10,%esp
	my_assert(elfheader->e_magic == 0x464C457FU);
f01002e3:	8d 85 ec fd ff ff    	lea    -0x214(%ebp),%eax
f01002e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
	my_assert(elfheader->e_phoff + elfheader->e_phnum * sizeof(struct Proghdr) <= SECTSIZE * SECTCOUNT);
f01002ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01002ef:	8b 00                	mov    (%eax),%eax
f01002f1:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f01002f6:	74 16                	je     f010030e <userprog_load+0x63>
f01002f8:	68 74 1e 10 f0       	push   $0xf0101e74
f01002fd:	68 96 1e 10 f0       	push   $0xf0101e96
f0100302:	6a 1a                	push   $0x1a
f0100304:	68 ab 1e 10 f0       	push   $0xf0101eab
f0100309:	e8 8c 1a 00 00       	call   f0101d9a <_panic>

f010030e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100311:	8b 50 1c             	mov    0x1c(%eax),%edx
f0100314:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100317:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
f010031b:	0f b7 c0             	movzwl %ax,%eax
f010031e:	c1 e0 05             	shl    $0x5,%eax
f0100321:	01 d0                	add    %edx,%eax
f0100323:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100328:	76 16                	jbe    f0100340 <userprog_load+0x95>
f010032a:	68 bc 1e 10 f0       	push   $0xf0101ebc
f010032f:	68 96 1e 10 f0       	push   $0xf0101e96
f0100334:	6a 1b                	push   $0x1b
f0100336:	68 ab 1e 10 f0       	push   $0xf0101eab
f010033b:	e8 5a 1a 00 00       	call   f0101d9a <_panic>
	struct Proghdr *ph = (struct Proghdr *) (header + elfheader->e_phoff);
	load_updir(get_pid());
f0100340:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100343:	8b 40 1c             	mov    0x1c(%eax),%eax
f0100346:	8d 95 ec fd ff ff    	lea    -0x214(%ebp),%edx
f010034c:	01 d0                	add    %edx,%eax
f010034e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for (int phnum = elfheader->e_phnum; phnum > 0; --phnum, ++ph)
f0100351:	e8 81 02 00 00       	call   f01005d7 <get_pid>
f0100356:	83 ec 0c             	sub    $0xc,%esp
f0100359:	50                   	push   %eax
f010035a:	e8 24 ff ff ff       	call   f0100283 <load_updir>
f010035f:	83 c4 10             	add    $0x10,%esp
		if (ph->p_type == 1) { // ELF_PROG_LOAD
f0100362:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100365:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
f0100369:	0f b7 c0             	movzwl %ax,%eax
f010036c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010036f:	e9 a5 00 00 00       	jmp    f0100419 <userprog_load+0x16e>
			printk("%s: ph->p_pa = %x\n", __func__, ph->p_pa);
f0100374:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100377:	8b 00                	mov    (%eax),%eax
f0100379:	83 f8 01             	cmp    $0x1,%eax
f010037c:	0f 85 8f 00 00 00    	jne    f0100411 <userprog_load+0x166>
			my_assert(ph->p_pa >= 0x1000000);         // don't overlap kernel
f0100382:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100385:	8b 40 0c             	mov    0xc(%eax),%eax
f0100388:	83 ec 04             	sub    $0x4,%esp
f010038b:	50                   	push   %eax
f010038c:	68 4c 1f 10 f0       	push   $0xf0101f4c
f0100391:	68 15 1f 10 f0       	push   $0xf0101f15
f0100396:	e8 7a 05 00 00       	call   f0100915 <printk>
f010039b:	83 c4 10             	add    $0x10,%esp
			ide_read((void *) ph->p_pa, offset + ph->p_offset, ph->p_filesz);
f010039e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003a1:	8b 40 0c             	mov    0xc(%eax),%eax
f01003a4:	3d ff ff ff 00       	cmp    $0xffffff,%eax
f01003a9:	77 16                	ja     f01003c1 <userprog_load+0x116>
f01003ab:	68 28 1f 10 f0       	push   $0xf0101f28
f01003b0:	68 96 1e 10 f0       	push   $0xf0101e96
f01003b5:	6a 22                	push   $0x22
f01003b7:	68 ab 1e 10 f0       	push   $0xf0101eab
f01003bc:	e8 d9 19 00 00       	call   f0101d9a <_panic>
			memset((void *) (ph->p_pa + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
f01003c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003c4:	8b 40 10             	mov    0x10(%eax),%eax
f01003c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01003ca:	8b 4a 04             	mov    0x4(%edx),%ecx
f01003cd:	8b 55 08             	mov    0x8(%ebp),%edx
f01003d0:	01 d1                	add    %edx,%ecx
f01003d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01003d5:	8b 52 0c             	mov    0xc(%edx),%edx
f01003d8:	83 ec 04             	sub    $0x4,%esp
f01003db:	50                   	push   %eax
f01003dc:	51                   	push   %ecx
f01003dd:	52                   	push   %edx
f01003de:	e8 a5 fc ff ff       	call   f0100088 <ide_read>
f01003e3:	83 c4 10             	add    $0x10,%esp
		}
f01003e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003e9:	8b 50 14             	mov    0x14(%eax),%edx
f01003ec:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003ef:	8b 40 10             	mov    0x10(%eax),%eax
f01003f2:	29 c2                	sub    %eax,%edx
f01003f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003f7:	8b 48 0c             	mov    0xc(%eax),%ecx
f01003fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01003fd:	8b 40 10             	mov    0x10(%eax),%eax
f0100400:	01 c8                	add    %ecx,%eax
f0100402:	83 ec 04             	sub    $0x4,%esp
f0100405:	52                   	push   %edx
f0100406:	6a 00                	push   $0x0
f0100408:	50                   	push   %eax
f0100409:	e8 e0 18 00 00       	call   f0101cee <memset>
f010040e:	83 c4 10             	add    $0x10,%esp
	my_assert(elfheader->e_phoff + elfheader->e_phnum * sizeof(struct Proghdr) <= SECTSIZE * SECTCOUNT);

	struct Proghdr *ph = (struct Proghdr *) (header + elfheader->e_phoff);
	load_updir(get_pid());
	for (int phnum = elfheader->e_phnum; phnum > 0; --phnum, ++ph)
		if (ph->p_type == 1) { // ELF_PROG_LOAD
f0100411:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
f0100415:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
f0100419:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010041d:	0f 8f 51 ff ff ff    	jg     f0100374 <userprog_load+0xc9>
			ide_read((void *) ph->p_pa, offset + ph->p_offset, ph->p_filesz);
			memset((void *) (ph->p_pa + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
		}
	// printk("Loading finished!, e_entry(va) is 0x%x\n", __func__, elfheader->e_entry); // ﻿0xF0101C98
	return elfheader->e_entry; // would be eip of pcb_init
}
f0100423:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0100426:	8b 40 18             	mov    0x18(%eax),%eax

f0100429:	c9                   	leave  
f010042a:	c3                   	ret    

f010042b <kernel_init>:



void kernel_init() {
    printk("Kernel init\n");
f010042b:	55                   	push   %ebp
f010042c:	89 e5                	mov    %esp,%ebp
f010042e:	81 ec 68 10 00 00    	sub    $0x1068,%esp
	init_serial();
f0100434:	83 ec 0c             	sub    $0xc,%esp
f0100437:	68 3e 1f 10 f0       	push   $0xf0101f3e
f010043c:	e8 d4 04 00 00       	call   f0100915 <printk>
f0100441:	83 c4 10             	add    $0x10,%esp
	init_timer();
f0100444:	e8 6d 05 00 00       	call   f01009b6 <init_serial>
	pic_init();
f0100449:	e8 8a 07 00 00       	call   f0100bd8 <init_timer>
	trap_init();
f010044e:	e8 49 00 00 00       	call   f010049c <pic_init>
	mem_init();
f0100453:	e8 eb 07 00 00       	call   f0100c43 <trap_init>

f0100458:	e8 41 02 00 00       	call   f010069e <mem_init>
	struct PCB userprog;
	pcb_init(&userprog, USER_START, userprog_load(300 * SECTSIZE), 2 | FL_IF);

f010045d:	83 ec 0c             	sub    $0xc,%esp
f0100460:	68 00 58 02 00       	push   $0x25800
f0100465:	e8 41 fe ff ff       	call   f01002ab <userprog_load>
f010046a:	83 c4 10             	add    $0x10,%esp
f010046d:	68 02 02 00 00       	push   $0x202
f0100472:	50                   	push   %eax
f0100473:	68 00 80 04 08       	push   $0x8048000
f0100478:	8d 85 a0 ef ff ff    	lea    -0x1060(%ebp),%eax
f010047e:	50                   	push   %eax
f010047f:	e8 5d 01 00 00       	call   f01005e1 <pcb_init>
f0100484:	83 c4 10             	add    $0x10,%esp
	pcb_exec(&userprog);
} // ﻿0x1000000 = 2^24   2^9*2^8
f0100487:	83 ec 0c             	sub    $0xc,%esp
f010048a:	8d 85 a0 ef ff ff    	lea    -0x1060(%ebp),%eax
f0100490:	50                   	push   %eax
f0100491:	e8 d5 01 00 00       	call   f010066b <pcb_exec>
f0100496:	83 c4 10             	add    $0x10,%esp
f0100499:	90                   	nop
f010049a:	c9                   	leave  
f010049b:	c3                   	ret    

f010049c <pic_init>:

#define KEYBOARD_IRQ_BIT 0x1
#define TIME_IRQ_BIT 0x2

void 
pic_init(void) {
f010049c:	55                   	push   %ebp
f010049d:	89 e5                	mov    %esp,%ebp
f010049f:	83 ec 50             	sub    $0x50,%esp
f01004a2:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f01004a9:	c6 45 ba ff          	movb   $0xff,-0x46(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01004ad:	0f b6 45 ba          	movzbl -0x46(%ebp),%eax
f01004b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01004b4:	ee                   	out    %al,(%dx)
f01004b5:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f01004bc:	c6 45 bb ff          	movb   $0xff,-0x45(%ebp)
f01004c0:	0f b6 45 bb          	movzbl -0x45(%ebp),%eax
f01004c4:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01004c7:	ee                   	out    %al,(%dx)
f01004c8:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%ebp)
f01004cf:	c6 45 bc 11          	movb   $0x11,-0x44(%ebp)
f01004d3:	0f b6 45 bc          	movzbl -0x44(%ebp),%eax
f01004d7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01004da:	ee                   	out    %al,(%dx)
f01004db:	c7 45 f0 21 00 00 00 	movl   $0x21,-0x10(%ebp)
f01004e2:	c6 45 bd 20          	movb   $0x20,-0x43(%ebp)
f01004e6:	0f b6 45 bd          	movzbl -0x43(%ebp),%eax
f01004ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01004ed:	ee                   	out    %al,(%dx)
f01004ee:	c7 45 ec 21 00 00 00 	movl   $0x21,-0x14(%ebp)
f01004f5:	c6 45 be 04          	movb   $0x4,-0x42(%ebp)
f01004f9:	0f b6 45 be          	movzbl -0x42(%ebp),%eax
f01004fd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100500:	ee                   	out    %al,(%dx)
f0100501:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0100508:	c6 45 bf 03          	movb   $0x3,-0x41(%ebp)
f010050c:	0f b6 45 bf          	movzbl -0x41(%ebp),%eax
f0100510:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100513:	ee                   	out    %al,(%dx)
f0100514:	c7 45 e4 a0 00 00 00 	movl   $0xa0,-0x1c(%ebp)
f010051b:	c6 45 c0 11          	movb   $0x11,-0x40(%ebp)
f010051f:	0f b6 45 c0          	movzbl -0x40(%ebp),%eax
f0100523:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100526:	ee                   	out    %al,(%dx)
f0100527:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%ebp)
f010052e:	c6 45 c1 28          	movb   $0x28,-0x3f(%ebp)
f0100532:	0f b6 45 c1          	movzbl -0x3f(%ebp),%eax
f0100536:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100539:	ee                   	out    %al,(%dx)
f010053a:	c7 45 dc a1 00 00 00 	movl   $0xa1,-0x24(%ebp)
f0100541:	c6 45 c2 02          	movb   $0x2,-0x3e(%ebp)
f0100545:	0f b6 45 c2          	movzbl -0x3e(%ebp),%eax
f0100549:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010054c:	ee                   	out    %al,(%dx)
f010054d:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0100554:	c6 45 c3 03          	movb   $0x3,-0x3d(%ebp)
f0100558:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
f010055c:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010055f:	ee                   	out    %al,(%dx)
f0100560:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%ebp)
f0100567:	c6 45 c4 68          	movb   $0x68,-0x3c(%ebp)
f010056b:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
f010056f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0100572:	ee                   	out    %al,(%dx)
f0100573:	c7 45 d0 20 00 00 00 	movl   $0x20,-0x30(%ebp)
f010057a:	c6 45 c5 0a          	movb   $0xa,-0x3b(%ebp)
f010057e:	0f b6 45 c5          	movzbl -0x3b(%ebp),%eax
f0100582:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0100585:	ee                   	out    %al,(%dx)
f0100586:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%ebp)
f010058d:	c6 45 c6 68          	movb   $0x68,-0x3a(%ebp)
f0100591:	0f b6 45 c6          	movzbl -0x3a(%ebp),%eax
f0100595:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0100598:	ee                   	out    %al,(%dx)
f0100599:	c7 45 c8 a0 00 00 00 	movl   $0xa0,-0x38(%ebp)
f01005a0:	c6 45 c7 0a          	movb   $0xa,-0x39(%ebp)
f01005a4:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
f01005a8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01005ab:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x68);             /* clear specific mask */
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);             /* OCW3 */
	outb(IO_PIC2, 0x0a);             /* OCW3 */
}
f01005ac:	90                   	nop
f01005ad:	c9                   	leave  
f01005ae:	c3                   	ret    

f01005af <load_updir>:

extern size_t npages;
extern struct PageInfo *pages;
extern pte_t user_pgdir[UPDIR_NUM][NPDENTRIES];

static inline void load_updir(int pid) {
f01005af:	55                   	push   %ebp
f01005b0:	89 e5                	mov    %esp,%ebp
f01005b2:	83 ec 10             	sub    $0x10,%esp
    uint32_t dir_addr = ((uint32_t)user_pgdir[pid]) - KERNBASE;
f01005b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01005b8:	c1 e0 0c             	shl    $0xc,%eax
f01005bb:	05 00 e0 16 f0       	add    $0xf016e000,%eax
f01005c0:	05 00 00 00 10       	add    $0x10000000,%eax
f01005c5:	89 45 fc             	mov    %eax,-0x4(%ebp)
f01005c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01005cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
}

static __inline void
lcr3(uint32_t val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01005ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01005d1:	0f 22 d8             	mov    %eax,%cr3
    // lcr3((uint32_t)entry_pgdir - KERNBASE);
    lcr3(dir_addr);
}
f01005d4:	90                   	nop
f01005d5:	c9                   	leave  
f01005d6:	c3                   	ret    

f01005d7 <get_pid>:

static uint32_t curr_pid;
struct PCB user_pcbs[UPCB_NUM];


uint32_t get_pid() {
f01005d7:	55                   	push   %ebp
f01005d8:	89 e5                	mov    %esp,%ebp
    return curr_pid;
f01005da:	a1 00 f0 10 f0       	mov    0xf010f000,%eax
}
f01005df:	5d                   	pop    %ebp
f01005e0:	c3                   	ret    

f01005e1 <pcb_init>:

void pcb_init(struct PCB *pcb, uintptr_t esp, uintptr_t eip, uint32_t eflags) {
f01005e1:	55                   	push   %ebp
f01005e2:	89 e5                	mov    %esp,%ebp
f01005e4:	83 ec 08             	sub    $0x8,%esp
    pcb->status = PCB_RUNNING;
f01005e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01005ea:	c7 40 08 03 00 00 00 	movl   $0x3,0x8(%eax)
    pcb->runned_time = 0;
f01005f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01005f4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    load_updir(pcb->pid);
f01005fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01005fe:	8b 00                	mov    (%eax),%eax
f0100600:	50                   	push   %eax
f0100601:	e8 a9 ff ff ff       	call   f01005af <load_updir>
f0100606:	83 c4 04             	add    $0x4,%esp

    memset(&pcb->tf, 0, sizeof(pcb->tf));
f0100609:	8b 45 08             	mov    0x8(%ebp),%eax
f010060c:	83 c0 14             	add    $0x14,%eax
f010060f:	83 ec 04             	sub    $0x4,%esp
f0100612:	6a 44                	push   $0x44
f0100614:	6a 00                	push   $0x0
f0100616:	50                   	push   %eax
f0100617:	e8 d2 16 00 00       	call   f0101cee <memset>
f010061c:	83 c4 10             	add    $0x10,%esp
    pcb->tf.tf_ds = pcb->tf.tf_es = pcb->tf.tf_ss = GD_UD | 3;
f010061f:	8b 45 08             	mov    0x8(%ebp),%eax
f0100622:	66 c7 40 54 23 00    	movw   $0x23,0x54(%eax)
f0100628:	8b 45 08             	mov    0x8(%ebp),%eax
f010062b:	0f b7 50 54          	movzwl 0x54(%eax),%edx
f010062f:	8b 45 08             	mov    0x8(%ebp),%eax
f0100632:	66 89 50 34          	mov    %dx,0x34(%eax)
f0100636:	8b 45 08             	mov    0x8(%ebp),%eax
f0100639:	0f b7 50 34          	movzwl 0x34(%eax),%edx
f010063d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100640:	66 89 50 38          	mov    %dx,0x38(%eax)
    pcb->tf.tf_esp = esp;
f0100644:	8b 45 08             	mov    0x8(%ebp),%eax
f0100647:	8b 55 0c             	mov    0xc(%ebp),%edx
f010064a:	89 50 50             	mov    %edx,0x50(%eax)
    pcb->tf.tf_cs = GD_UT | 3;
f010064d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100650:	66 c7 40 48 1b 00    	movw   $0x1b,0x48(%eax)
    pcb->tf.tf_eip = eip;
f0100656:	8b 45 08             	mov    0x8(%ebp),%eax
f0100659:	8b 55 10             	mov    0x10(%ebp),%edx
f010065c:	89 50 44             	mov    %edx,0x44(%eax)
    pcb->tf.tf_eflags = eflags;
f010065f:	8b 45 08             	mov    0x8(%ebp),%eax
f0100662:	8b 55 14             	mov    0x14(%ebp),%edx
f0100665:	89 50 4c             	mov    %edx,0x4c(%eax)
}
f0100668:	90                   	nop
f0100669:	c9                   	leave  
f010066a:	c3                   	ret    

f010066b <pcb_exec>:

void pcb_exec(struct PCB *pcb) {
f010066b:	55                   	push   %ebp
f010066c:	89 e5                	mov    %esp,%ebp
f010066e:	83 ec 08             	sub    $0x8,%esp
    // TODO: lcr3
    pcb->status = PCB_FREE;
f0100671:	8b 45 08             	mov    0x8(%ebp),%eax
f0100674:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            "\tpopal\n"
            "\tpopl %%es\n"
            "\tpopl %%ds\n"
            "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
            "\tiret"
    : : "g" (&pcb->tf) : "memory");
f010067b:	8b 45 08             	mov    0x8(%ebp),%eax
f010067e:	83 c0 14             	add    $0x14,%eax
}

void pcb_exec(struct PCB *pcb) {
    // TODO: lcr3
    pcb->status = PCB_FREE;
    __asm __volatile("movl %0,%%esp\n"
f0100681:	89 c4                	mov    %eax,%esp
f0100683:	61                   	popa   
f0100684:	07                   	pop    %es
f0100685:	1f                   	pop    %ds
f0100686:	83 c4 08             	add    $0x8,%esp
f0100689:	cf                   	iret   
            "\tpopl %%es\n"
            "\tpopl %%ds\n"
            "\taddl $0x8,%%esp\n" /* skip tf_trapno and tf_errcode */
            "\tiret"
    : : "g" (&pcb->tf) : "memory");
    panic("iret failed");  /* mostly to placate the compiler */
f010068a:	83 ec 04             	sub    $0x4,%esp
f010068d:	68 5a 1f 10 f0       	push   $0xf0101f5a
f0100692:	6a 27                	push   $0x27
f0100694:	68 66 1f 10 f0       	push   $0xf0101f66
f0100699:	e8 fc 16 00 00       	call   f0101d9a <_panic>

f010069e <mem_init>:
static pte_t user_pgtable[USER_DIR_NUM][NPTENTRIES]; // restricted by qemu memory (112 MB for user)
static uint32_t userpg_used[UPCB_NUM];



void mem_init() {
f010069e:	55                   	push   %ebp
f010069f:	89 e5                	mov    %esp,%ebp
f01006a1:	83 ec 18             	sub    $0x18,%esp

    uint32_t flags = PTE_P | PTE_W | PTE_U;
f01006a4:	c7 45 f0 07 00 00 00 	movl   $0x7,-0x10(%ebp)
    for(int i = 0; i < UPCB_NUM; i++) {     // copy kernel page map
f01006ab:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01006b2:	eb 2a                	jmp    f01006de <mem_init+0x40>
        user_pgdir[i][0] = entry_pgdir[0];  // [0, 4MB)
f01006b4:	a1 00 40 10 f0       	mov    0xf0104000,%eax
f01006b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006bc:	c1 e2 0c             	shl    $0xc,%edx
f01006bf:	81 c2 00 e0 16 f0    	add    $0xf016e000,%edx
f01006c5:	89 02                	mov    %eax,(%edx)
        user_pgdir[i][KERNBASE >> PDXSHIFT] = entry_pgdir[KERNBASE >> PDXSHIFT];  // [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
f01006c7:	a1 00 4f 10 f0       	mov    0xf0104f00,%eax
f01006cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006cf:	c1 e2 0c             	shl    $0xc,%edx
f01006d2:	81 c2 00 ef 16 f0    	add    $0xf016ef00,%edx
f01006d8:	89 02                	mov    %eax,(%edx)


void mem_init() {

    uint32_t flags = PTE_P | PTE_W | PTE_U;
    for(int i = 0; i < UPCB_NUM; i++) {     // copy kernel page map
f01006da:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
f01006de:	83 7d f4 3f          	cmpl   $0x3f,-0xc(%ebp)
f01006e2:	7e d0                	jle    f01006b4 <mem_init+0x16>
        user_pgdir[i][0] = entry_pgdir[0];  // [0, 4MB)
        user_pgdir[i][KERNBASE >> PDXSHIFT] = entry_pgdir[KERNBASE >> PDXSHIFT];  // [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)
    }
    // panic(" Stop. ");
    alloc_page(0x8048000, flags, 0); // save in process 0
f01006e4:	83 ec 04             	sub    $0x4,%esp
f01006e7:	6a 00                	push   $0x0
f01006e9:	ff 75 f0             	pushl  -0x10(%ebp)
f01006ec:	68 00 80 04 08       	push   $0x8048000
f01006f1:	e8 1b 00 00 00       	call   f0100711 <alloc_page>
f01006f6:	83 c4 10             	add    $0x10,%esp
    alloc_page(0x8048800, flags, 0); // save in process 0
f01006f9:	83 ec 04             	sub    $0x4,%esp
f01006fc:	6a 00                	push   $0x0
f01006fe:	ff 75 f0             	pushl  -0x10(%ebp)
f0100701:	68 00 88 04 08       	push   $0x8048800
f0100706:	e8 06 00 00 00       	call   f0100711 <alloc_page>
f010070b:	83 c4 10             	add    $0x10,%esp
}
f010070e:	90                   	nop
f010070f:	c9                   	leave  
f0100710:	c3                   	ret    

f0100711 <alloc_page>:


void alloc_page(uintptr_t va, uint32_t flags, uint32_t pid) {
f0100711:	55                   	push   %ebp
f0100712:	89 e5                	mov    %esp,%ebp
f0100714:	83 ec 18             	sub    $0x18,%esp
    my_assert(pid == get_pid());  // TODO: other cases?
f0100717:	e8 bb fe ff ff       	call   f01005d7 <get_pid>
f010071c:	3b 45 10             	cmp    0x10(%ebp),%eax
f010071f:	74 16                	je     f0100737 <alloc_page+0x26>
f0100721:	68 74 1f 10 f0       	push   $0xf0101f74
f0100726:	68 85 1f 10 f0       	push   $0xf0101f85
f010072b:	6a 22                	push   $0x22
f010072d:	68 9a 1f 10 f0       	push   $0xf0101f9a
f0100732:	e8 63 16 00 00       	call   f0101d9a <_panic>
    int32_t used = userpg_used[pid]; // 0 ~ 27
f0100737:	8b 45 10             	mov    0x10(%ebp),%eax
f010073a:	8b 04 85 00 c0 12 f0 	mov    -0xfed4000(,%eax,4),%eax
f0100741:	89 45 f0             	mov    %eax,-0x10(%ebp)
    user_pgdir[pid][PDX(va)] = (pde_t) (((uintptr_t) &user_pgtable[used] - KERNBASE) | flags);
f0100744:	8b 45 08             	mov    0x8(%ebp),%eax
f0100747:	c1 e8 16             	shr    $0x16,%eax
f010074a:	89 c1                	mov    %eax,%ecx
f010074c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010074f:	c1 e0 0c             	shl    $0xc,%eax
f0100752:	05 00 00 11 f0       	add    $0xf0110000,%eax
f0100757:	05 00 00 00 10       	add    $0x10000000,%eax
f010075c:	0b 45 0c             	or     0xc(%ebp),%eax
f010075f:	8b 55 10             	mov    0x10(%ebp),%edx
f0100762:	c1 e2 0a             	shl    $0xa,%edx
f0100765:	01 ca                	add    %ecx,%edx
f0100767:	89 04 95 00 e0 16 f0 	mov    %eax,-0xfe92000(,%edx,4)
    for (int i = 0; i < NPTENTRIES; ++i) {
f010076e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100775:	eb 2f                	jmp    f01007a6 <alloc_page+0x95>
        user_pgtable[used][i] = (pte_t) ((KERN_MEM + (used << PDXSHIFT)) | i << PTXSHIFT | flags);
f0100777:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010077a:	c1 e0 16             	shl    $0x16,%eax
f010077d:	8d 90 00 00 00 01    	lea    0x1000000(%eax),%edx
f0100783:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100786:	c1 e0 0c             	shl    $0xc,%eax
f0100789:	09 d0                	or     %edx,%eax
f010078b:	0b 45 0c             	or     0xc(%ebp),%eax
f010078e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100791:	89 d1                	mov    %edx,%ecx
f0100793:	c1 e1 0a             	shl    $0xa,%ecx
f0100796:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100799:	01 ca                	add    %ecx,%edx
f010079b:	89 04 95 00 00 11 f0 	mov    %eax,-0xfef0000(,%edx,4)

void alloc_page(uintptr_t va, uint32_t flags, uint32_t pid) {
    my_assert(pid == get_pid());  // TODO: other cases?
    int32_t used = userpg_used[pid]; // 0 ~ 27
    user_pgdir[pid][PDX(va)] = (pde_t) (((uintptr_t) &user_pgtable[used] - KERNBASE) | flags);
    for (int i = 0; i < NPTENTRIES; ++i) {
f01007a2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
f01007a6:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f01007ad:	7e c8                	jle    f0100777 <alloc_page+0x66>
        user_pgtable[used][i] = (pte_t) ((KERN_MEM + (used << PDXSHIFT)) | i << PTXSHIFT | flags);
        // printk("0x%x\n", user_pgtable[userpg_used][i]);
    }
    printk("%s: Allocated 4GB at 0x%x to 0x%x\n", __func__, va, KERN_MEM + (used << PDXSHIFT));
f01007af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007b2:	c1 e0 16             	shl    $0x16,%eax
f01007b5:	05 00 00 00 01       	add    $0x1000000,%eax
f01007ba:	50                   	push   %eax
f01007bb:	ff 75 08             	pushl  0x8(%ebp)
f01007be:	68 cc 1f 10 f0       	push   $0xf0101fcc
f01007c3:	68 a8 1f 10 f0       	push   $0xf0101fa8
f01007c8:	e8 48 01 00 00       	call   f0100915 <printk>
f01007cd:	83 c4 10             	add    $0x10,%esp
    userpg_used[pid]++;
f01007d0:	8b 45 10             	mov    0x10(%ebp),%eax
f01007d3:	8b 04 85 00 c0 12 f0 	mov    -0xfed4000(,%eax,4),%eax
f01007da:	8d 50 01             	lea    0x1(%eax),%edx
f01007dd:	8b 45 10             	mov    0x10(%ebp),%eax
f01007e0:	89 14 85 00 c0 12 f0 	mov    %edx,-0xfed4000(,%eax,4)
}
f01007e7:	90                   	nop
f01007e8:	c9                   	leave  
f01007e9:	c3                   	ret    

f01007ea <vfprintf>:

char* convert(unsigned int, int);
void puts(char* s);

/* implement this function to support printk */
void vfprintf(void (*printer)(char), const char *ctl, va_list arg) {
f01007ea:	55                   	push   %ebp
f01007eb:	89 e5                	mov    %esp,%ebp
f01007ed:	83 ec 18             	sub    $0x18,%esp
	for(; *ctl != '\0'; ctl ++) {
f01007f0:	e9 0f 01 00 00       	jmp    f0100904 <vfprintf+0x11a>
		int32_t i;
		char* s;
		if (*ctl != '%') {
f01007f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01007f8:	0f b6 00             	movzbl (%eax),%eax
f01007fb:	3c 25                	cmp    $0x25,%al
f01007fd:	74 1a                	je     f0100819 <vfprintf+0x2f>
			printer(*ctl);
f01007ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100802:	0f b6 00             	movzbl (%eax),%eax
f0100805:	0f be c0             	movsbl %al,%eax
f0100808:	83 ec 0c             	sub    $0xc,%esp
f010080b:	50                   	push   %eax
f010080c:	8b 45 08             	mov    0x8(%ebp),%eax
f010080f:	ff d0                	call   *%eax
f0100811:	83 c4 10             	add    $0x10,%esp
f0100814:	e9 e7 00 00 00       	jmp    f0100900 <vfprintf+0x116>
		}
		else switch(*(++ctl)) {
f0100819:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
f010081d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100820:	0f b6 00             	movzbl (%eax),%eax
f0100823:	0f be c0             	movsbl %al,%eax
f0100826:	83 f8 64             	cmp    $0x64,%eax
f0100829:	74 26                	je     f0100851 <vfprintf+0x67>
f010082b:	83 f8 64             	cmp    $0x64,%eax
f010082e:	7f 0e                	jg     f010083e <vfprintf+0x54>
f0100830:	83 f8 63             	cmp    $0x63,%eax
f0100833:	0f 84 88 00 00 00    	je     f01008c1 <vfprintf+0xd7>
			case 's':
				s = va_arg(arg, char *);       //Fetch string
				puts(s);
				break; 
			default :
				break;
f0100839:	e9 c2 00 00 00       	jmp    f0100900 <vfprintf+0x116>
		int32_t i;
		char* s;
		if (*ctl != '%') {
			printer(*ctl);
		}
		else switch(*(++ctl)) {
f010083e:	83 f8 73             	cmp    $0x73,%eax
f0100841:	0f 84 9c 00 00 00    	je     f01008e3 <vfprintf+0xf9>
f0100847:	83 f8 78             	cmp    $0x78,%eax
f010084a:	74 48                	je     f0100894 <vfprintf+0xaa>
			case 's':
				s = va_arg(arg, char *);       //Fetch string
				puts(s);
				break; 
			default :
				break;
f010084c:	e9 af 00 00 00       	jmp    f0100900 <vfprintf+0x116>
		if (*ctl != '%') {
			printer(*ctl);
		}
		else switch(*(++ctl)) {
			case 'd':
				i = va_arg(arg, int);
f0100851:	8b 45 10             	mov    0x10(%ebp),%eax
f0100854:	8d 50 04             	lea    0x4(%eax),%edx
f0100857:	89 55 10             	mov    %edx,0x10(%ebp)
f010085a:	8b 00                	mov    (%eax),%eax
f010085c:	89 45 f4             	mov    %eax,-0xc(%ebp)
				if(i < 0) {
f010085f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100863:	79 10                	jns    f0100875 <vfprintf+0x8b>
					i = -i;
f0100865:	f7 5d f4             	negl   -0xc(%ebp)
					printer('-');
f0100868:	83 ec 0c             	sub    $0xc,%esp
f010086b:	6a 2d                	push   $0x2d
f010086d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100870:	ff d0                	call   *%eax
f0100872:	83 c4 10             	add    $0x10,%esp
				}
				puts(convert(i, 10));
f0100875:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100878:	83 ec 08             	sub    $0x8,%esp
f010087b:	6a 0a                	push   $0xa
f010087d:	50                   	push   %eax
f010087e:	e8 b8 00 00 00       	call   f010093b <convert>
f0100883:	83 c4 10             	add    $0x10,%esp
f0100886:	83 ec 0c             	sub    $0xc,%esp
f0100889:	50                   	push   %eax
f010088a:	e8 f9 00 00 00       	call   f0100988 <puts>
f010088f:	83 c4 10             	add    $0x10,%esp
				break;
f0100892:	eb 6c                	jmp    f0100900 <vfprintf+0x116>
			case 'x':
				i = va_arg(arg, unsigned int);
f0100894:	8b 45 10             	mov    0x10(%ebp),%eax
f0100897:	8d 50 04             	lea    0x4(%eax),%edx
f010089a:	89 55 10             	mov    %edx,0x10(%ebp)
f010089d:	8b 00                	mov    (%eax),%eax
f010089f:	89 45 f4             	mov    %eax,-0xc(%ebp)
				puts(convert(i, 16));
f01008a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01008a5:	83 ec 08             	sub    $0x8,%esp
f01008a8:	6a 10                	push   $0x10
f01008aa:	50                   	push   %eax
f01008ab:	e8 8b 00 00 00       	call   f010093b <convert>
f01008b0:	83 c4 10             	add    $0x10,%esp
f01008b3:	83 ec 0c             	sub    $0xc,%esp
f01008b6:	50                   	push   %eax
f01008b7:	e8 cc 00 00 00       	call   f0100988 <puts>
f01008bc:	83 c4 10             	add    $0x10,%esp
				break;
f01008bf:	eb 3f                	jmp    f0100900 <vfprintf+0x116>
			case 'c':
				i = va_arg(arg, int);   
f01008c1:	8b 45 10             	mov    0x10(%ebp),%eax
f01008c4:	8d 50 04             	lea    0x4(%eax),%edx
f01008c7:	89 55 10             	mov    %edx,0x10(%ebp)
f01008ca:	8b 00                	mov    (%eax),%eax
f01008cc:	89 45 f4             	mov    %eax,-0xc(%ebp)
				printer(i);
f01008cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01008d2:	0f be c0             	movsbl %al,%eax
f01008d5:	83 ec 0c             	sub    $0xc,%esp
f01008d8:	50                   	push   %eax
f01008d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01008dc:	ff d0                	call   *%eax
f01008de:	83 c4 10             	add    $0x10,%esp
				break; 
f01008e1:	eb 1d                	jmp    f0100900 <vfprintf+0x116>
			case 's':
				s = va_arg(arg, char *);       //Fetch string
f01008e3:	8b 45 10             	mov    0x10(%ebp),%eax
f01008e6:	8d 50 04             	lea    0x4(%eax),%edx
f01008e9:	89 55 10             	mov    %edx,0x10(%ebp)
f01008ec:	8b 00                	mov    (%eax),%eax
f01008ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
				puts(s);
f01008f1:	83 ec 0c             	sub    $0xc,%esp
f01008f4:	ff 75 f0             	pushl  -0x10(%ebp)
f01008f7:	e8 8c 00 00 00       	call   f0100988 <puts>
f01008fc:	83 c4 10             	add    $0x10,%esp
				break; 
f01008ff:	90                   	nop
char* convert(unsigned int, int);
void puts(char* s);

/* implement this function to support printk */
void vfprintf(void (*printer)(char), const char *ctl, va_list arg) {
	for(; *ctl != '\0'; ctl ++) {
f0100900:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
f0100904:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100907:	0f b6 00             	movzbl (%eax),%eax
f010090a:	84 c0                	test   %al,%al
f010090c:	0f 85 e3 fe ff ff    	jne    f01007f5 <vfprintf+0xb>
	for(;*str != '\0'; str ++) printer(*str);

	str = "() is not implemented!\n";
	for(;*str != '\0'; str ++) printer(*str);
	*/
}
f0100912:	90                   	nop
f0100913:	c9                   	leave  
f0100914:	c3                   	ret    

f0100915 <printk>:

extern void serial_printc(char);

void printk(const char *ctl, ...) {
f0100915:	55                   	push   %ebp
f0100916:	89 e5                	mov    %esp,%ebp
f0100918:	83 ec 18             	sub    $0x18,%esp
	va_list arg;
	va_start(arg, ctl);
f010091b:	8d 45 0c             	lea    0xc(%ebp),%eax
f010091e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vfprintf(serial_printc, ctl, arg);
f0100921:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100924:	83 ec 04             	sub    $0x4,%esp
f0100927:	50                   	push   %eax
f0100928:	ff 75 08             	pushl  0x8(%ebp)
f010092b:	68 66 0a 10 f0       	push   $0xf0100a66
f0100930:	e8 b5 fe ff ff       	call   f01007ea <vfprintf>
f0100935:	83 c4 10             	add    $0x10,%esp
	va_end(arg);
}
f0100938:	90                   	nop
f0100939:	c9                   	leave  
f010093a:	c3                   	ret    

f010093b <convert>:

char *convert(unsigned int num, int base) { 
f010093b:	55                   	push   %ebp
f010093c:	89 e5                	mov    %esp,%ebp
f010093e:	83 ec 10             	sub    $0x10,%esp
    static char Representation[] = "0123456789ABCDEF";
    static char buffer[50]; 
    char *ptr; 

    ptr = &buffer[49]; 
f0100941:	c7 45 fc 31 c1 12 f0 	movl   $0xf012c131,-0x4(%ebp)
    *ptr = '\0'; 
f0100948:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010094b:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--ptr = Representation[num % base]; 
f010094e:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
f0100952:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0100955:	8b 45 08             	mov    0x8(%ebp),%eax
f0100958:	ba 00 00 00 00       	mov    $0x0,%edx
f010095d:	f7 f1                	div    %ecx
f010095f:	89 d0                	mov    %edx,%eax
f0100961:	0f b6 90 00 50 10 f0 	movzbl -0xfefb000(%eax),%edx
f0100968:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010096b:	88 10                	mov    %dl,(%eax)
        num /= base; 
f010096d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0100970:	8b 45 08             	mov    0x8(%ebp),%eax
f0100973:	ba 00 00 00 00       	mov    $0x0,%edx
f0100978:	f7 f1                	div    %ecx
f010097a:	89 45 08             	mov    %eax,0x8(%ebp)
    } while(num != 0); 
f010097d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0100981:	75 cb                	jne    f010094e <convert+0x13>

    return(ptr); 
f0100983:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0100986:	c9                   	leave  
f0100987:	c3                   	ret    

f0100988 <puts>:

void puts(char* s) {
f0100988:	55                   	push   %ebp
f0100989:	89 e5                	mov    %esp,%ebp
f010098b:	83 ec 08             	sub    $0x8,%esp
	while(*s != '\0') {
f010098e:	eb 19                	jmp    f01009a9 <puts+0x21>
		serial_printc(*s);
f0100990:	8b 45 08             	mov    0x8(%ebp),%eax
f0100993:	0f b6 00             	movzbl (%eax),%eax
f0100996:	0f be c0             	movsbl %al,%eax
f0100999:	83 ec 0c             	sub    $0xc,%esp
f010099c:	50                   	push   %eax
f010099d:	e8 c4 00 00 00       	call   f0100a66 <serial_printc>
f01009a2:	83 c4 10             	add    $0x10,%esp
		s++;
f01009a5:	83 45 08 01          	addl   $0x1,0x8(%ebp)

    return(ptr); 
}

void puts(char* s) {
	while(*s != '\0') {
f01009a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01009ac:	0f b6 00             	movzbl (%eax),%eax
f01009af:	84 c0                	test   %al,%al
f01009b1:	75 dd                	jne    f0100990 <puts+0x8>
		serial_printc(*s);
		s++;
	}
}
f01009b3:	90                   	nop
f01009b4:	c9                   	leave  
f01009b5:	c3                   	ret    

f01009b6 <init_serial>:
#include <inc/x86.h>
#define PORT 0x3f8   /* COM1 */
#define ANSI_COLOR_BLUE    "\x1b[34m"

void init_serial() {
f01009b6:	55                   	push   %ebp
f01009b7:	89 e5                	mov    %esp,%ebp
f01009b9:	83 ec 30             	sub    $0x30,%esp
f01009bc:	c7 45 fc f9 03 00 00 	movl   $0x3f9,-0x4(%ebp)
f01009c3:	c6 45 dd 00          	movb   $0x0,-0x23(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01009c7:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
f01009cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01009ce:	ee                   	out    %al,(%dx)
f01009cf:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%ebp)
f01009d6:	c6 45 de 80          	movb   $0x80,-0x22(%ebp)
f01009da:	0f b6 45 de          	movzbl -0x22(%ebp),%eax
f01009de:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01009e1:	ee                   	out    %al,(%dx)
f01009e2:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%ebp)
f01009e9:	c6 45 df 03          	movb   $0x3,-0x21(%ebp)
f01009ed:	0f b6 45 df          	movzbl -0x21(%ebp),%eax
f01009f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01009f4:	ee                   	out    %al,(%dx)
f01009f5:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%ebp)
f01009fc:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
f0100a00:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
f0100a04:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a07:	ee                   	out    %al,(%dx)
f0100a08:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%ebp)
f0100a0f:	c6 45 e1 03          	movb   $0x3,-0x1f(%ebp)
f0100a13:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
f0100a17:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a1a:	ee                   	out    %al,(%dx)
f0100a1b:	c7 45 e8 fa 03 00 00 	movl   $0x3fa,-0x18(%ebp)
f0100a22:	c6 45 e2 c7          	movb   $0xc7,-0x1e(%ebp)
f0100a26:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
f0100a2a:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a2d:	ee                   	out    %al,(%dx)
f0100a2e:	c7 45 e4 fc 03 00 00 	movl   $0x3fc,-0x1c(%ebp)
f0100a35:	c6 45 e3 0b          	movb   $0xb,-0x1d(%ebp)
f0100a39:	0f b6 45 e3          	movzbl -0x1d(%ebp),%eax
f0100a3d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a40:	ee                   	out    %al,(%dx)
   outb(PORT + 0, 0x03);
   outb(PORT + 1, 0x00);
   outb(PORT + 3, 0x03);
   outb(PORT + 2, 0xC7);
   outb(PORT + 4, 0x0B);
}
f0100a41:	90                   	nop
f0100a42:	c9                   	leave  
f0100a43:	c3                   	ret    

f0100a44 <is_serial_idle>:

int is_serial_idle() {
f0100a44:	55                   	push   %ebp
f0100a45:	89 e5                	mov    %esp,%ebp
f0100a47:	83 ec 10             	sub    $0x10,%esp
f0100a4a:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a51:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100a54:	89 c2                	mov    %eax,%edx
f0100a56:	ec                   	in     (%dx),%al
f0100a57:	88 45 fb             	mov    %al,-0x5(%ebp)
	return data;
f0100a5a:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   return inb(PORT + 5) & 0x20;
f0100a5e:	0f b6 c0             	movzbl %al,%eax
f0100a61:	83 e0 20             	and    $0x20,%eax
}
f0100a64:	c9                   	leave  
f0100a65:	c3                   	ret    

f0100a66 <serial_printc>:
void serial_printc(char c) {
f0100a66:	55                   	push   %ebp
f0100a67:	89 e5                	mov    %esp,%ebp
f0100a69:	83 ec 14             	sub    $0x14,%esp
f0100a6c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100a6f:	88 45 ec             	mov    %al,-0x14(%ebp)
	while(!is_serial_idle())
f0100a72:	90                   	nop
f0100a73:	e8 cc ff ff ff       	call   f0100a44 <is_serial_idle>
f0100a78:	85 c0                	test   %eax,%eax
f0100a7a:	74 f7                	je     f0100a73 <serial_printc+0xd>
		;
	outb(PORT, c);
f0100a7c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
f0100a80:	0f b6 c0             	movzbl %al,%eax
f0100a83:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)
f0100a8a:	88 45 fb             	mov    %al,-0x5(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a8d:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
f0100a91:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0100a94:	ee                   	out    %al,(%dx)
}
f0100a95:	90                   	nop
f0100a96:	c9                   	leave  
f0100a97:	c3                   	ret    

f0100a98 <wait_for_interrupt>:
#define __X86_CPU_H__

#include "common.h"

static inline void
wait_for_interrupt() {
f0100a98:	55                   	push   %ebp
f0100a99:	89 e5                	mov    %esp,%ebp
	asm volatile("hlt");
f0100a9b:	f4                   	hlt    
}
f0100a9c:	90                   	nop
f0100a9d:	5d                   	pop    %ebp
f0100a9e:	c3                   	ret    

f0100a9f <enable_interrupt>:
	data[2] = ((uint32_t)addr) >> 16;
	asm volatile("lidt (%0)" : : "r"(data));
}

static inline void
enable_interrupt(void) {
f0100a9f:	55                   	push   %ebp
f0100aa0:	89 e5                	mov    %esp,%ebp
	asm volatile("sti");
f0100aa2:	fb                   	sti    
}
f0100aa3:	90                   	nop
f0100aa4:	5d                   	pop    %ebp
f0100aa5:	c3                   	ret    

f0100aa6 <disable_interrupt>:

static inline void
disable_interrupt(void) {
f0100aa6:	55                   	push   %ebp
f0100aa7:	89 e5                	mov    %esp,%ebp
	asm volatile("cli");
f0100aa9:	fa                   	cli    
}
f0100aaa:	90                   	nop
f0100aab:	5d                   	pop    %ebp
f0100aac:	c3                   	ret    

f0100aad <sys_vprintk>:
#include <inc/video.h>
#include <inc/cpu.h>
#include <inc/memlayout.h>
#include "trap.h"

void sys_vprintk(const char *ctl, va_list arg) {
f0100aad:	55                   	push   %ebp
f0100aae:	89 e5                	mov    %esp,%ebp
f0100ab0:	83 ec 08             	sub    $0x8,%esp
    extern void vfprintf(void (*)(char), const char *, va_list);
    extern void serial_printc(char);
    vfprintf(serial_printc, ctl, arg);
f0100ab3:	83 ec 04             	sub    $0x4,%esp
f0100ab6:	ff 75 0c             	pushl  0xc(%ebp)
f0100ab9:	ff 75 08             	pushl  0x8(%ebp)
f0100abc:	68 66 0a 10 f0       	push   $0xf0100a66
f0100ac1:	e8 24 fd ff ff       	call   f01007ea <vfprintf>
f0100ac6:	83 c4 10             	add    $0x10,%esp
}
f0100ac9:	90                   	nop
f0100aca:	c9                   	leave  
f0100acb:	c3                   	ret    

f0100acc <sys_timer>:

void sys_timer(void (*handler)(void)) {
f0100acc:	55                   	push   %ebp
f0100acd:	89 e5                	mov    %esp,%ebp
    do_timer = handler;
f0100acf:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ad2:	a3 24 e0 1a f0       	mov    %eax,0xf01ae024
}
f0100ad7:	90                   	nop
f0100ad8:	5d                   	pop    %ebp
f0100ad9:	c3                   	ret    

f0100ada <sys_keyboard>:

void sys_keyboard(void (*handler)(int)) {
f0100ada:	55                   	push   %ebp
f0100adb:	89 e5                	mov    %esp,%ebp
    do_keyboard = handler;
f0100add:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ae0:	a3 20 e0 1a f0       	mov    %eax,0xf01ae020
}
f0100ae5:	90                   	nop
f0100ae6:	5d                   	pop    %ebp
f0100ae7:	c3                   	ret    

f0100ae8 <sys_display>:

void sys_display(uint8_t *buffer) {
f0100ae8:	55                   	push   %ebp
f0100ae9:	89 e5                	mov    %esp,%ebp
f0100aeb:	83 ec 08             	sub    $0x8,%esp
    memcpy(KERNBASE + VMEM_ADDR, buffer, SCR_SIZE);
f0100aee:	83 ec 04             	sub    $0x4,%esp
f0100af1:	68 00 fa 00 00       	push   $0xfa00
f0100af6:	ff 75 08             	pushl  0x8(%ebp)
f0100af9:	68 00 00 0a f0       	push   $0xf00a0000
f0100afe:	e8 cd 11 00 00       	call   f0101cd0 <memcpy>
f0100b03:	83 c4 10             	add    $0x10,%esp
}
f0100b06:	90                   	nop
f0100b07:	c9                   	leave  
f0100b08:	c3                   	ret    

f0100b09 <sys_sleep>:

void sys_sleep() {
f0100b09:	55                   	push   %ebp
f0100b0a:	89 e5                	mov    %esp,%ebp
    enable_interrupt();
f0100b0c:	e8 8e ff ff ff       	call   f0100a9f <enable_interrupt>
    wait_for_interrupt();
f0100b11:	e8 82 ff ff ff       	call   f0100a98 <wait_for_interrupt>
    disable_interrupt();
f0100b16:	e8 8b ff ff ff       	call   f0100aa6 <disable_interrupt>
}
f0100b1b:	90                   	nop
f0100b1c:	5d                   	pop    %ebp
f0100b1d:	c3                   	ret    

f0100b1e <sys_crash>:

__attribute__((noreturn)) void sys_crash() {
f0100b1e:	55                   	push   %ebp
f0100b1f:	89 e5                	mov    %esp,%ebp
    for (;;) __asm __volatile("cli; hlt");
f0100b21:	fa                   	cli    
f0100b22:	f4                   	hlt    
f0100b23:	eb fc                	jmp    f0100b21 <sys_crash+0x3>

f0100b25 <syscall_handler>:
}

uint32_t syscall_handler(struct Trapframe *tf) {
f0100b25:	55                   	push   %ebp
f0100b26:	89 e5                	mov    %esp,%ebp
f0100b28:	83 ec 08             	sub    $0x8,%esp
#define arg1 tf->tf_regs.reg_edx
#define arg2 tf->tf_regs.reg_ecx
#define arg3 tf->tf_regs.reg_ebx
#define arg4 tf->tf_regs.reg_edi
#define arg5 tf->tf_regs.reg_esi
    switch (tf->tf_regs.reg_eax) {  // syscall number
f0100b2b:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b2e:	8b 40 1c             	mov    0x1c(%eax),%eax
f0100b31:	83 f8 05             	cmp    $0x5,%eax
f0100b34:	0f 87 97 00 00 00    	ja     f0100bd1 <syscall_handler+0xac>
f0100b3a:	8b 04 85 e4 1f 10 f0 	mov    -0xfefe01c(,%eax,4),%eax
f0100b41:	ff e0                	jmp    *%eax
        case SYS_vprintk:
            sys_vprintk((const char *) arg1, (va_list) arg2);
f0100b43:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b46:	8b 40 18             	mov    0x18(%eax),%eax
f0100b49:	89 c2                	mov    %eax,%edx
f0100b4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b4e:	8b 40 14             	mov    0x14(%eax),%eax
f0100b51:	83 ec 08             	sub    $0x8,%esp
f0100b54:	52                   	push   %edx
f0100b55:	50                   	push   %eax
f0100b56:	e8 52 ff ff ff       	call   f0100aad <sys_vprintk>
f0100b5b:	83 c4 10             	add    $0x10,%esp
            return 0;
f0100b5e:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b63:	eb 71                	jmp    f0100bd6 <syscall_handler+0xb1>
        case SYS_timer:
            sys_timer((void (*)(void)) arg1);
f0100b65:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b68:	8b 40 14             	mov    0x14(%eax),%eax
f0100b6b:	83 ec 0c             	sub    $0xc,%esp
f0100b6e:	50                   	push   %eax
f0100b6f:	e8 58 ff ff ff       	call   f0100acc <sys_timer>
f0100b74:	83 c4 10             	add    $0x10,%esp
            return 0;
f0100b77:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b7c:	eb 58                	jmp    f0100bd6 <syscall_handler+0xb1>
        case SYS_keyboard:
            sys_keyboard((void (*)(int)) arg1);
f0100b7e:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b81:	8b 40 14             	mov    0x14(%eax),%eax
f0100b84:	83 ec 0c             	sub    $0xc,%esp
f0100b87:	50                   	push   %eax
f0100b88:	e8 4d ff ff ff       	call   f0100ada <sys_keyboard>
f0100b8d:	83 c4 10             	add    $0x10,%esp
            return 0;
f0100b90:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b95:	eb 3f                	jmp    f0100bd6 <syscall_handler+0xb1>
        case SYS_display:
            sys_display((uint8_t *) arg1);
f0100b97:	8b 45 08             	mov    0x8(%ebp),%eax
f0100b9a:	8b 40 14             	mov    0x14(%eax),%eax
f0100b9d:	83 ec 0c             	sub    $0xc,%esp
f0100ba0:	50                   	push   %eax
f0100ba1:	e8 42 ff ff ff       	call   f0100ae8 <sys_display>
f0100ba6:	83 c4 10             	add    $0x10,%esp
            return 0;
f0100ba9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bae:	eb 26                	jmp    f0100bd6 <syscall_handler+0xb1>
        case SYS_sleep:
            sys_sleep();
f0100bb0:	e8 54 ff ff ff       	call   f0100b09 <sys_sleep>
            return 0;
f0100bb5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bba:	eb 1a                	jmp    f0100bd6 <syscall_handler+0xb1>
        case SYS_crash:
            printk("Crashed.\n");
f0100bbc:	83 ec 0c             	sub    $0xc,%esp
f0100bbf:	68 d8 1f 10 f0       	push   $0xf0101fd8
f0100bc4:	e8 4c fd ff ff       	call   f0100915 <printk>
f0100bc9:	83 c4 10             	add    $0x10,%esp
            sys_crash();
f0100bcc:	e8 4d ff ff ff       	call   f0100b1e <sys_crash>
            return 0; // never exec
        default:
            return (uint32_t) -1;
f0100bd1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
}
f0100bd6:	c9                   	leave  
f0100bd7:	c3                   	ret    

f0100bd8 <init_timer>:
	.operate_mode = 2,  // rate generator, for more accuracy
	.access_mode  = 3,  // low byte / high byte, see below
	.channel      = 0,  // use channel 0
};

void init_timer(void) {
f0100bd8:	55                   	push   %ebp
f0100bd9:	89 e5                	mov    %esp,%ebp
f0100bdb:	83 ec 20             	sub    $0x20,%esp
	int counter = PIT_FREQUENCE / HZ;
f0100bde:	c7 45 fc 9b 2e 00 00 	movl   $0x2e9b,-0x4(%ebp)
	outb(PORT_CMD, mode.val);
f0100be5:	0f b6 05 11 50 10 f0 	movzbl 0xf0105011,%eax
f0100bec:	0f b6 c0             	movzbl %al,%eax
f0100bef:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)
f0100bf6:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100bf9:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
f0100bfd:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100c00:	ee                   	out    %al,(%dx)
	outb(PORT_CH_0, counter & 0xFF);         // access low byte
f0100c01:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100c04:	0f b6 c0             	movzbl %al,%eax
f0100c07:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0100c0e:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100c11:	0f b6 45 ee          	movzbl -0x12(%ebp),%eax
f0100c15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100c18:	ee                   	out    %al,(%dx)
	outb(PORT_CH_0, (counter >> 8) & 0xFF);  // access high byte
f0100c19:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100c1c:	c1 f8 08             	sar    $0x8,%eax
f0100c1f:	0f b6 c0             	movzbl %al,%eax
f0100c22:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0100c29:	88 45 ef             	mov    %al,-0x11(%ebp)
f0100c2c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0100c30:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100c33:	ee                   	out    %al,(%dx)
}
f0100c34:	90                   	nop
f0100c35:	c9                   	leave  
f0100c36:	c3                   	ret    

f0100c37 <lgdt>:
	__asm __volatile("lidt (%0)" : : "r" (p));
}

static __inline void
lgdt(void *p)
{
f0100c37:	55                   	push   %ebp
f0100c38:	89 e5                	mov    %esp,%ebp
	__asm __volatile("lgdt (%0)" : : "r" (p));
f0100c3a:	8b 45 08             	mov    0x8(%ebp),%eax
f0100c3d:	0f 01 10             	lgdtl  (%eax)
}
f0100c40:	90                   	nop
f0100c41:	5d                   	pop    %ebp
f0100c42:	c3                   	ret    

f0100c43 <trap_init>:
extern uint32_t trap_handlers[];
struct Taskstate pts;

void (*do_timer)(void), (*do_keyboard)(int);

void trap_init(void) {
f0100c43:	55                   	push   %ebp
f0100c44:	89 e5                	mov    %esp,%ebp
f0100c46:	83 ec 10             	sub    $0x10,%esp
    lgdt(&gdt_pd);
f0100c49:	68 50 50 10 f0       	push   $0xf0105050
f0100c4e:	e8 e4 ff ff ff       	call   f0100c37 <lgdt>
f0100c53:	83 c4 04             	add    $0x4,%esp
    // The kernel never uses GS or FS, so we leave those set to
    // the user data segment.
    asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0100c56:	b8 23 00 00 00       	mov    $0x23,%eax
f0100c5b:	8e e8                	mov    %eax,%gs
    asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0100c5d:	b8 23 00 00 00       	mov    $0x23,%eax
f0100c62:	8e e0                	mov    %eax,%fs
    // The kernel does use ES, DS, and SS.  We'll change between
    // the kernel and user data segments as needed.
    asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0100c64:	b8 10 00 00 00       	mov    $0x10,%eax
f0100c69:	8e c0                	mov    %eax,%es
    asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0100c6b:	b8 10 00 00 00       	mov    $0x10,%eax
f0100c70:	8e d8                	mov    %eax,%ds
    asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0100c72:	b8 10 00 00 00       	mov    $0x10,%eax
f0100c77:	8e d0                	mov    %eax,%ss
    // Load the kernel text segment into CS.
    asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));
f0100c79:	ea 80 0c 10 f0 08 00 	ljmp   $0x8,$0xf0100c80
f0100c80:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%ebp)

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
f0100c86:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
f0100c8a:	0f 00 d0             	lldt   %ax
    // For good measure, clear the local descriptor table (LDT),
    // since we don't use it.
    lldt(0);

    int i = 0;
f0100c8d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for ( ; i < 256 ; i++) {
f0100c94:	e9 c3 00 00 00       	jmp    f0100d5c <trap_init+0x119>
        SETGATE(idt[i], 0, GD_KT, trap_handlers[i], 0);
f0100c99:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100c9c:	8b 04 85 00 e0 10 f0 	mov    -0xfef2000(,%eax,4),%eax
f0100ca3:	89 c2                	mov    %eax,%edx
f0100ca5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100ca8:	66 89 14 c5 40 c1 12 	mov    %dx,-0xfed3ec0(,%eax,8)
f0100caf:	f0 
f0100cb0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100cb3:	66 c7 04 c5 42 c1 12 	movw   $0x8,-0xfed3ebe(,%eax,8)
f0100cba:	f0 08 00 
f0100cbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100cc0:	0f b6 14 c5 44 c1 12 	movzbl -0xfed3ebc(,%eax,8),%edx
f0100cc7:	f0 
f0100cc8:	83 e2 e0             	and    $0xffffffe0,%edx
f0100ccb:	88 14 c5 44 c1 12 f0 	mov    %dl,-0xfed3ebc(,%eax,8)
f0100cd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100cd5:	0f b6 14 c5 44 c1 12 	movzbl -0xfed3ebc(,%eax,8),%edx
f0100cdc:	f0 
f0100cdd:	83 e2 1f             	and    $0x1f,%edx
f0100ce0:	88 14 c5 44 c1 12 f0 	mov    %dl,-0xfed3ebc(,%eax,8)
f0100ce7:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100cea:	0f b6 14 c5 45 c1 12 	movzbl -0xfed3ebb(,%eax,8),%edx
f0100cf1:	f0 
f0100cf2:	83 e2 f0             	and    $0xfffffff0,%edx
f0100cf5:	83 ca 0e             	or     $0xe,%edx
f0100cf8:	88 14 c5 45 c1 12 f0 	mov    %dl,-0xfed3ebb(,%eax,8)
f0100cff:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100d02:	0f b6 14 c5 45 c1 12 	movzbl -0xfed3ebb(,%eax,8),%edx
f0100d09:	f0 
f0100d0a:	83 e2 ef             	and    $0xffffffef,%edx
f0100d0d:	88 14 c5 45 c1 12 f0 	mov    %dl,-0xfed3ebb(,%eax,8)
f0100d14:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100d17:	0f b6 14 c5 45 c1 12 	movzbl -0xfed3ebb(,%eax,8),%edx
f0100d1e:	f0 
f0100d1f:	83 e2 9f             	and    $0xffffff9f,%edx
f0100d22:	88 14 c5 45 c1 12 f0 	mov    %dl,-0xfed3ebb(,%eax,8)
f0100d29:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100d2c:	0f b6 14 c5 45 c1 12 	movzbl -0xfed3ebb(,%eax,8),%edx
f0100d33:	f0 
f0100d34:	83 ca 80             	or     $0xffffff80,%edx
f0100d37:	88 14 c5 45 c1 12 f0 	mov    %dl,-0xfed3ebb(,%eax,8)
f0100d3e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100d41:	8b 04 85 00 e0 10 f0 	mov    -0xfef2000(,%eax,4),%eax
f0100d48:	c1 e8 10             	shr    $0x10,%eax
f0100d4b:	89 c2                	mov    %eax,%edx
f0100d4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100d50:	66 89 14 c5 46 c1 12 	mov    %dx,-0xfed3eba(,%eax,8)
f0100d57:	f0 
    // For good measure, clear the local descriptor table (LDT),
    // since we don't use it.
    lldt(0);

    int i = 0;
    for ( ; i < 256 ; i++) {
f0100d58:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
f0100d5c:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
f0100d63:	0f 8e 30 ff ff ff    	jle    f0100c99 <trap_init+0x56>
        SETGATE(idt[i], 0, GD_KT, trap_handlers[i], 0);
    }

    // init break point
    SETGATE(idt[T_BRKPT], 0, GD_KT, trap_handlers[T_BRKPT], 3);
f0100d69:	a1 0c e0 10 f0       	mov    0xf010e00c,%eax
f0100d6e:	66 a3 58 c1 12 f0    	mov    %ax,0xf012c158
f0100d74:	66 c7 05 5a c1 12 f0 	movw   $0x8,0xf012c15a
f0100d7b:	08 00 
f0100d7d:	0f b6 05 5c c1 12 f0 	movzbl 0xf012c15c,%eax
f0100d84:	83 e0 e0             	and    $0xffffffe0,%eax
f0100d87:	a2 5c c1 12 f0       	mov    %al,0xf012c15c
f0100d8c:	0f b6 05 5c c1 12 f0 	movzbl 0xf012c15c,%eax
f0100d93:	83 e0 1f             	and    $0x1f,%eax
f0100d96:	a2 5c c1 12 f0       	mov    %al,0xf012c15c
f0100d9b:	0f b6 05 5d c1 12 f0 	movzbl 0xf012c15d,%eax
f0100da2:	83 e0 f0             	and    $0xfffffff0,%eax
f0100da5:	83 c8 0e             	or     $0xe,%eax
f0100da8:	a2 5d c1 12 f0       	mov    %al,0xf012c15d
f0100dad:	0f b6 05 5d c1 12 f0 	movzbl 0xf012c15d,%eax
f0100db4:	83 e0 ef             	and    $0xffffffef,%eax
f0100db7:	a2 5d c1 12 f0       	mov    %al,0xf012c15d
f0100dbc:	0f b6 05 5d c1 12 f0 	movzbl 0xf012c15d,%eax
f0100dc3:	83 c8 60             	or     $0x60,%eax
f0100dc6:	a2 5d c1 12 f0       	mov    %al,0xf012c15d
f0100dcb:	0f b6 05 5d c1 12 f0 	movzbl 0xf012c15d,%eax
f0100dd2:	83 c8 80             	or     $0xffffff80,%eax
f0100dd5:	a2 5d c1 12 f0       	mov    %al,0xf012c15d
f0100dda:	a1 0c e0 10 f0       	mov    0xf010e00c,%eax
f0100ddf:	c1 e8 10             	shr    $0x10,%eax
f0100de2:	66 a3 5e c1 12 f0    	mov    %ax,0xf012c15e
    // init syscall
    SETGATE(idt[T_SYSCALL], 0, GD_KT, trap_handlers[T_SYSCALL], 3);
f0100de8:	a1 00 e2 10 f0       	mov    0xf010e200,%eax
f0100ded:	66 a3 40 c5 12 f0    	mov    %ax,0xf012c540
f0100df3:	66 c7 05 42 c5 12 f0 	movw   $0x8,0xf012c542
f0100dfa:	08 00 
f0100dfc:	0f b6 05 44 c5 12 f0 	movzbl 0xf012c544,%eax
f0100e03:	83 e0 e0             	and    $0xffffffe0,%eax
f0100e06:	a2 44 c5 12 f0       	mov    %al,0xf012c544
f0100e0b:	0f b6 05 44 c5 12 f0 	movzbl 0xf012c544,%eax
f0100e12:	83 e0 1f             	and    $0x1f,%eax
f0100e15:	a2 44 c5 12 f0       	mov    %al,0xf012c544
f0100e1a:	0f b6 05 45 c5 12 f0 	movzbl 0xf012c545,%eax
f0100e21:	83 e0 f0             	and    $0xfffffff0,%eax
f0100e24:	83 c8 0e             	or     $0xe,%eax
f0100e27:	a2 45 c5 12 f0       	mov    %al,0xf012c545
f0100e2c:	0f b6 05 45 c5 12 f0 	movzbl 0xf012c545,%eax
f0100e33:	83 e0 ef             	and    $0xffffffef,%eax
f0100e36:	a2 45 c5 12 f0       	mov    %al,0xf012c545
f0100e3b:	0f b6 05 45 c5 12 f0 	movzbl 0xf012c545,%eax
f0100e42:	83 c8 60             	or     $0x60,%eax
f0100e45:	a2 45 c5 12 f0       	mov    %al,0xf012c545
f0100e4a:	0f b6 05 45 c5 12 f0 	movzbl 0xf012c545,%eax
f0100e51:	83 c8 80             	or     $0xffffff80,%eax
f0100e54:	a2 45 c5 12 f0       	mov    %al,0xf012c545
f0100e59:	a1 00 e2 10 f0       	mov    0xf010e200,%eax
f0100e5e:	c1 e8 10             	shr    $0x10,%eax
f0100e61:	66 a3 46 c5 12 f0    	mov    %ax,0xf012c546

    pts.ts_esp0 = KSTACKTOP;
f0100e67:	c7 05 44 e0 1a f0 00 	movl   $0xf0400000,0xf01ae044
f0100e6e:	00 40 f0 
    pts.ts_ss0 = GD_KD;
f0100e71:	66 c7 05 48 e0 1a f0 	movw   $0x10,0xf01ae048
f0100e78:	10 00 

    // Initialize the TSS slot of the gdt.
    gdt[GD_TSS0 >> 3] = SEG16(STS_T32A, (uint32_t) (&pts),
f0100e7a:	66 c7 05 48 50 10 f0 	movw   $0x68,0xf0105048
f0100e81:	68 00 
f0100e83:	b8 40 e0 1a f0       	mov    $0xf01ae040,%eax
f0100e88:	66 a3 4a 50 10 f0    	mov    %ax,0xf010504a
f0100e8e:	b8 40 e0 1a f0       	mov    $0xf01ae040,%eax
f0100e93:	c1 e8 10             	shr    $0x10,%eax
f0100e96:	a2 4c 50 10 f0       	mov    %al,0xf010504c
f0100e9b:	0f b6 05 4d 50 10 f0 	movzbl 0xf010504d,%eax
f0100ea2:	83 e0 f0             	and    $0xfffffff0,%eax
f0100ea5:	83 c8 09             	or     $0x9,%eax
f0100ea8:	a2 4d 50 10 f0       	mov    %al,0xf010504d
f0100ead:	0f b6 05 4d 50 10 f0 	movzbl 0xf010504d,%eax
f0100eb4:	83 c8 10             	or     $0x10,%eax
f0100eb7:	a2 4d 50 10 f0       	mov    %al,0xf010504d
f0100ebc:	0f b6 05 4d 50 10 f0 	movzbl 0xf010504d,%eax
f0100ec3:	83 e0 9f             	and    $0xffffff9f,%eax
f0100ec6:	a2 4d 50 10 f0       	mov    %al,0xf010504d
f0100ecb:	0f b6 05 4d 50 10 f0 	movzbl 0xf010504d,%eax
f0100ed2:	83 c8 80             	or     $0xffffff80,%eax
f0100ed5:	a2 4d 50 10 f0       	mov    %al,0xf010504d
f0100eda:	0f b6 05 4e 50 10 f0 	movzbl 0xf010504e,%eax
f0100ee1:	83 e0 f0             	and    $0xfffffff0,%eax
f0100ee4:	a2 4e 50 10 f0       	mov    %al,0xf010504e
f0100ee9:	0f b6 05 4e 50 10 f0 	movzbl 0xf010504e,%eax
f0100ef0:	83 e0 ef             	and    $0xffffffef,%eax
f0100ef3:	a2 4e 50 10 f0       	mov    %al,0xf010504e
f0100ef8:	0f b6 05 4e 50 10 f0 	movzbl 0xf010504e,%eax
f0100eff:	83 e0 df             	and    $0xffffffdf,%eax
f0100f02:	a2 4e 50 10 f0       	mov    %al,0xf010504e
f0100f07:	0f b6 05 4e 50 10 f0 	movzbl 0xf010504e,%eax
f0100f0e:	83 c8 40             	or     $0x40,%eax
f0100f11:	a2 4e 50 10 f0       	mov    %al,0xf010504e
f0100f16:	0f b6 05 4e 50 10 f0 	movzbl 0xf010504e,%eax
f0100f1d:	83 e0 7f             	and    $0x7f,%eax
f0100f20:	a2 4e 50 10 f0       	mov    %al,0xf010504e
f0100f25:	b8 40 e0 1a f0       	mov    $0xf01ae040,%eax
f0100f2a:	c1 e8 18             	shr    $0x18,%eax
f0100f2d:	a2 4f 50 10 f0       	mov    %al,0xf010504f
                                      sizeof(struct Taskstate), 0);
    gdt[GD_TSS0 >> 3].sd_s = 0;
f0100f32:	0f b6 05 4d 50 10 f0 	movzbl 0xf010504d,%eax
f0100f39:	83 e0 ef             	and    $0xffffffef,%eax
f0100f3c:	a2 4d 50 10 f0       	mov    %al,0xf010504d
f0100f41:	66 c7 45 f6 28 00    	movw   $0x28,-0xa(%ebp)
}

static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f0100f47:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0100f4b:	0f 00 d8             	ltr    %ax
f0100f4e:	c7 45 f8 58 50 10 f0 	movl   $0xf0105058,-0x8(%ebp)
}

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
f0100f55:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100f58:	0f 01 18             	lidtl  (%eax)
    // bottom three bits are special; we leave them 0)
    ltr(GD_TSS0);

    // Load the IDT
    lidt(&idt_pd);
}
f0100f5b:	90                   	nop
f0100f5c:	c9                   	leave  
f0100f5d:	c3                   	ret    

f0100f5e <trap>:


void trap(struct Trapframe *tf) {
f0100f5e:	55                   	push   %ebp
f0100f5f:	89 e5                	mov    %esp,%ebp
f0100f61:	83 ec 38             	sub    $0x38,%esp
    // The environment may have set DF and some versions
    // of GCC rely on DF being clear
    asm volatile("cld" ::: "cc");
f0100f64:	fc                   	cld    

static __inline uint32_t
read_eflags(void)
{
	uint32_t eflags;
	__asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0100f65:	9c                   	pushf  
f0100f66:	58                   	pop    %eax
f0100f67:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	return eflags;
f0100f6a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
    // Check that interrupts are disabled.  If this assertion
    // fails, DO NOT be tempted to fix it by inserting a "cli" in
    // the interrupt path.
    my_assert(!(read_eflags() & FL_IF));
f0100f6d:	25 00 02 00 00       	and    $0x200,%eax
f0100f72:	85 c0                	test   %eax,%eax
f0100f74:	74 16                	je     f0100f8c <trap+0x2e>
f0100f76:	68 fc 1f 10 f0       	push   $0xf0101ffc
f0100f7b:	68 15 20 10 f0       	push   $0xf0102015
f0100f80:	6a 60                	push   $0x60
f0100f82:	68 2a 20 10 f0       	push   $0xf010202a
f0100f87:	e8 0e 0e 00 00       	call   f0101d9a <_panic>

    switch (tf->tf_trapno) {
f0100f8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f8f:	8b 40 28             	mov    0x28(%eax),%eax
f0100f92:	83 f8 20             	cmp    $0x20,%eax
f0100f95:	0f 84 cb 00 00 00    	je     f0101066 <trap+0x108>
f0100f9b:	83 f8 20             	cmp    $0x20,%eax
f0100f9e:	77 14                	ja     f0100fb4 <trap+0x56>
f0100fa0:	83 f8 0d             	cmp    $0xd,%eax
f0100fa3:	74 49                	je     f0100fee <trap+0x90>
f0100fa5:	83 f8 0e             	cmp    $0xe,%eax
f0100fa8:	74 5c                	je     f0101006 <trap+0xa8>
f0100faa:	83 f8 06             	cmp    $0x6,%eax
f0100fad:	74 27                	je     f0100fd6 <trap+0x78>
f0100faf:	e9 4e 01 00 00       	jmp    f0101102 <trap+0x1a4>
f0100fb4:	83 f8 2e             	cmp    $0x2e,%eax
f0100fb7:	0f 84 6e 01 00 00    	je     f010112b <trap+0x1cd>
f0100fbd:	3d 80 00 00 00       	cmp    $0x80,%eax
f0100fc2:	0f 84 83 00 00 00    	je     f010104b <trap+0xed>
f0100fc8:	83 f8 21             	cmp    $0x21,%eax
f0100fcb:	0f 84 ae 00 00 00    	je     f010107f <trap+0x121>
f0100fd1:	e9 2c 01 00 00       	jmp    f0101102 <trap+0x1a4>
        case T_ILLOP:
            panic("----> Illegal opcode at 0x%x.\n", tf->tf_eip);
f0100fd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fd9:	8b 40 30             	mov    0x30(%eax),%eax
f0100fdc:	50                   	push   %eax
f0100fdd:	68 38 20 10 f0       	push   $0xf0102038
f0100fe2:	6a 64                	push   $0x64
f0100fe4:	68 2a 20 10 f0       	push   $0xf010202a
f0100fe9:	e8 ac 0d 00 00       	call   f0101d9a <_panic>
        case T_GPFLT:
            panic("----> General protection fault at 0x%x.\n", tf->tf_eip);
f0100fee:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ff1:	8b 40 30             	mov    0x30(%eax),%eax
f0100ff4:	50                   	push   %eax
f0100ff5:	68 58 20 10 f0       	push   $0xf0102058
f0100ffa:	6a 66                	push   $0x66
f0100ffc:	68 2a 20 10 f0       	push   $0xf010202a
f0101001:	e8 94 0d 00 00       	call   f0101d9a <_panic>
        case T_PGFLT:

            alloc_page(rcr2(), PTE_P | PTE_W | PTE_U, get_pid());
f0101006:	e8 cc f5 ff ff       	call   f01005d7 <get_pid>
f010100b:	89 c2                	mov    %eax,%edx

static __inline uint32_t
rcr2(void)
{
	uint32_t val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010100d:	0f 20 d0             	mov    %cr2,%eax
f0101010:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return val;
f0101013:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101016:	83 ec 04             	sub    $0x4,%esp
f0101019:	52                   	push   %edx
f010101a:	6a 07                	push   $0x7
f010101c:	50                   	push   %eax
f010101d:	e8 ef f6 ff ff       	call   f0100711 <alloc_page>
f0101022:	83 c4 10             	add    $0x10,%esp
            printk("----> Page fault at 0x%x, va=0x%x, pid=%d.\n", tf->tf_eip, rcr2(), get_pid());
f0101025:	e8 ad f5 ff ff       	call   f01005d7 <get_pid>
f010102a:	89 c1                	mov    %eax,%ecx

static __inline uint32_t
rcr2(void)
{
	uint32_t val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010102c:	0f 20 d0             	mov    %cr2,%eax
f010102f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return val;
f0101032:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101035:	8b 45 08             	mov    0x8(%ebp),%eax
f0101038:	8b 40 30             	mov    0x30(%eax),%eax
f010103b:	51                   	push   %ecx
f010103c:	52                   	push   %edx
f010103d:	50                   	push   %eax
f010103e:	68 84 20 10 f0       	push   $0xf0102084
f0101043:	e8 cd f8 ff ff       	call   f0100915 <printk>
f0101048:	83 c4 10             	add    $0x10,%esp
            // panic("");
        case T_SYSCALL:
            tf->tf_regs.reg_eax = syscall_handler(tf);
f010104b:	83 ec 0c             	sub    $0xc,%esp
f010104e:	ff 75 08             	pushl  0x8(%ebp)
f0101051:	e8 cf fa ff ff       	call   f0100b25 <syscall_handler>
f0101056:	83 c4 10             	add    $0x10,%esp
f0101059:	89 c2                	mov    %eax,%edx
f010105b:	8b 45 08             	mov    0x8(%ebp),%eax
f010105e:	89 50 1c             	mov    %edx,0x1c(%eax)
            break;
f0101061:	e9 cc 00 00 00       	jmp    f0101132 <trap+0x1d4>
        case IRQ_OFFSET + IRQ_TIMER:
            if (do_timer != NULL) do_timer();
f0101066:	a1 24 e0 1a f0       	mov    0xf01ae024,%eax
f010106b:	85 c0                	test   %eax,%eax
f010106d:	0f 84 bb 00 00 00    	je     f010112e <trap+0x1d0>
f0101073:	a1 24 e0 1a f0       	mov    0xf01ae024,%eax
f0101078:	ff d0                	call   *%eax
            break;
f010107a:	e9 af 00 00 00       	jmp    f010112e <trap+0x1d0>
f010107f:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101086:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101089:	89 c2                	mov    %eax,%edx
f010108b:	ec                   	in     (%dx),%al
f010108c:	88 45 d0             	mov    %al,-0x30(%ebp)
	return data;
f010108f:	0f b6 45 d0          	movzbl -0x30(%ebp),%eax
        case IRQ_OFFSET + IRQ_KBD: {
            uint32_t code = inb(0x60), val = inb(0x61);
f0101093:	0f b6 c0             	movzbl %al,%eax
f0101096:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101099:	c7 45 dc 61 00 00 00 	movl   $0x61,-0x24(%ebp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01010a3:	89 c2                	mov    %eax,%edx
f01010a5:	ec                   	in     (%dx),%al
f01010a6:	88 45 d1             	mov    %al,-0x2f(%ebp)
	return data;
f01010a9:	0f b6 45 d1          	movzbl -0x2f(%ebp),%eax
f01010ad:	0f b6 c0             	movzbl %al,%eax
f01010b0:	89 45 e0             	mov    %eax,-0x20(%ebp)
            outb(0x61, (uint8_t) (val | 0x80));
f01010b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01010b6:	83 c8 80             	or     $0xffffff80,%eax
f01010b9:	0f b6 c0             	movzbl %al,%eax
f01010bc:	c7 45 d8 61 00 00 00 	movl   $0x61,-0x28(%ebp)
f01010c3:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01010c6:	0f b6 45 d2          	movzbl -0x2e(%ebp),%eax
f01010ca:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01010cd:	ee                   	out    %al,(%dx)
            outb(0x61, (uint8_t) val);
f01010ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01010d1:	0f b6 c0             	movzbl %al,%eax
f01010d4:	c7 45 f0 61 00 00 00 	movl   $0x61,-0x10(%ebp)
f01010db:	88 45 d3             	mov    %al,-0x2d(%ebp)
f01010de:	0f b6 45 d3          	movzbl -0x2d(%ebp),%eax
f01010e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01010e5:	ee                   	out    %al,(%dx)
            if (do_keyboard != NULL) do_keyboard(code);
f01010e6:	a1 20 e0 1a f0       	mov    0xf01ae020,%eax
f01010eb:	85 c0                	test   %eax,%eax
f01010ed:	74 42                	je     f0101131 <trap+0x1d3>
f01010ef:	a1 20 e0 1a f0       	mov    0xf01ae020,%eax
f01010f4:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01010f7:	83 ec 0c             	sub    $0xc,%esp
f01010fa:	52                   	push   %edx
f01010fb:	ff d0                	call   *%eax
f01010fd:	83 c4 10             	add    $0x10,%esp
            break;
f0101100:	eb 2f                	jmp    f0101131 <trap+0x1d3>
        }
        case IRQ_OFFSET + IRQ_IDE: break;   // ignore IDE IRQ
        default:
            panic("----> Unknown interrupt #%d (err=0x%x) at 0x%x.\n", tf->tf_trapno, tf->tf_err, tf->tf_eip);
f0101102:	8b 45 08             	mov    0x8(%ebp),%eax
f0101105:	8b 48 30             	mov    0x30(%eax),%ecx
f0101108:	8b 45 08             	mov    0x8(%ebp),%eax
f010110b:	8b 50 2c             	mov    0x2c(%eax),%edx
f010110e:	8b 45 08             	mov    0x8(%ebp),%eax
f0101111:	8b 40 28             	mov    0x28(%eax),%eax
f0101114:	83 ec 08             	sub    $0x8,%esp
f0101117:	51                   	push   %ecx
f0101118:	52                   	push   %edx
f0101119:	50                   	push   %eax
f010111a:	68 b0 20 10 f0       	push   $0xf01020b0
f010111f:	6a 7b                	push   $0x7b
f0101121:	68 2a 20 10 f0       	push   $0xf010202a
f0101126:	e8 6f 0c 00 00       	call   f0101d9a <_panic>
            outb(0x61, (uint8_t) (val | 0x80));
            outb(0x61, (uint8_t) val);
            if (do_keyboard != NULL) do_keyboard(code);
            break;
        }
        case IRQ_OFFSET + IRQ_IDE: break;   // ignore IDE IRQ
f010112b:	90                   	nop
f010112c:	eb 04                	jmp    f0101132 <trap+0x1d4>
        case T_SYSCALL:
            tf->tf_regs.reg_eax = syscall_handler(tf);
            break;
        case IRQ_OFFSET + IRQ_TIMER:
            if (do_timer != NULL) do_timer();
            break;
f010112e:	90                   	nop
f010112f:	eb 01                	jmp    f0101132 <trap+0x1d4>
        case IRQ_OFFSET + IRQ_KBD: {
            uint32_t code = inb(0x60), val = inb(0x61);
            outb(0x61, (uint8_t) (val | 0x80));
            outb(0x61, (uint8_t) val);
            if (do_keyboard != NULL) do_keyboard(code);
            break;
f0101131:	90                   	nop
        }
        case IRQ_OFFSET + IRQ_IDE: break;   // ignore IDE IRQ
        default:
            panic("----> Unknown interrupt #%d (err=0x%x) at 0x%x.\n", tf->tf_trapno, tf->tf_err, tf->tf_eip);
    }
}
f0101132:	90                   	nop
f0101133:	c9                   	leave  
f0101134:	c3                   	ret    
f0101135:	66 90                	xchg   %ax,%ax
f0101137:	90                   	nop
f0101138:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
f010113e:	00 00                	add    %al,(%eax)
f0101140:	fe 4f 52             	decb   0x52(%edi)
f0101143:	e4                   	.byte 0xe4

f0101144 <entry>:
.globl		_start
_start = RELOC(entry)

.globl entry
entry:
	movw	$0x1234,0x472			# warm boot
f0101144:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f010114b:	34 12 
	# sufficient until we set up our real page table in mem_init
	# in lab 2.

	# Load the physical address of entry_pgdir into cr3.  entry_pgdir
	# is defined in entrypgdir.c.
	movl	$(RELOC(entry_pgdir)), %eax
f010114d:	b8 00 40 10 00       	mov    $0x104000,%eax
	movl	%eax, %cr3
f0101152:	0f 22 d8             	mov    %eax,%cr3
	# Turn on paging.
	movl	%cr0, %eax
f0101155:	0f 20 c0             	mov    %cr0,%eax
	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax
f0101158:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl	%eax, %cr0
f010115d:	0f 22 c0             	mov    %eax,%cr0

	# Now paging is enabled, but we're still running at a low EIP
	# (why is this okay?).  Jump up above KERNBASE before entering
	# C code.
	mov	$relocated, %eax
f0101160:	b8 67 11 10 f0       	mov    $0xf0101167,%eax
	jmp	*%eax
f0101165:	ff e0                	jmp    *%eax

f0101167 <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f0101167:	bd 00 00 00 00       	mov    $0x0,%ebp

	# Set the stack pointer
	movl	$0xF0400000,%esp
f010116c:	bc 00 00 40 f0       	mov    $0xf0400000,%esp

	# now to C code
	call	kernel_init
f0101171:	e8 b5 f2 ff ff       	call   f010042b <kernel_init>

f0101176 <spin>:

	# Should never get here, but in case we do, just spin.
spin:
    jmp	spin
f0101176:	eb fe                	jmp    f0101176 <spin>

f0101178 <thdlr0>:
.text

/*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
TRAPHANDLER_NOEC(thdlr0, 0)
f0101178:	6a 00                	push   $0x0
f010117a:	6a 00                	push   $0x0
f010117c:	e9 ce 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101181:	90                   	nop

f0101182 <thdlr1>:
TRAPHANDLER_NOEC(thdlr1, 1)
f0101182:	6a 00                	push   $0x0
f0101184:	6a 01                	push   $0x1
f0101186:	e9 c4 0a 00 00       	jmp    f0101c4f <_alltraps>
f010118b:	90                   	nop

f010118c <thdlr2>:
TRAPHANDLER_NOEC(thdlr2, 2)
f010118c:	6a 00                	push   $0x0
f010118e:	6a 02                	push   $0x2
f0101190:	e9 ba 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101195:	90                   	nop

f0101196 <thdlr3>:
TRAPHANDLER_NOEC(thdlr3, 3)
f0101196:	6a 00                	push   $0x0
f0101198:	6a 03                	push   $0x3
f010119a:	e9 b0 0a 00 00       	jmp    f0101c4f <_alltraps>
f010119f:	90                   	nop

f01011a0 <thdlr4>:
TRAPHANDLER_NOEC(thdlr4, 4)
f01011a0:	6a 00                	push   $0x0
f01011a2:	6a 04                	push   $0x4
f01011a4:	e9 a6 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011a9:	90                   	nop

f01011aa <thdlr5>:
TRAPHANDLER_NOEC(thdlr5, 5)
f01011aa:	6a 00                	push   $0x0
f01011ac:	6a 05                	push   $0x5
f01011ae:	e9 9c 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011b3:	90                   	nop

f01011b4 <thdlr6>:
TRAPHANDLER_NOEC(thdlr6, 6)
f01011b4:	6a 00                	push   $0x0
f01011b6:	6a 06                	push   $0x6
f01011b8:	e9 92 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011bd:	90                   	nop

f01011be <thdlr7>:
TRAPHANDLER_NOEC(thdlr7, 7)
f01011be:	6a 00                	push   $0x0
f01011c0:	6a 07                	push   $0x7
f01011c2:	e9 88 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011c7:	90                   	nop

f01011c8 <thdlr8>:
TRAPHANDLER(thdlr8, 8)
f01011c8:	6a 08                	push   $0x8
f01011ca:	e9 80 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011cf:	90                   	nop

f01011d0 <thdlr9>:
TRAPHANDLER_NOEC(thdlr9, 9)
f01011d0:	6a 00                	push   $0x0
f01011d2:	6a 09                	push   $0x9
f01011d4:	e9 76 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011d9:	90                   	nop

f01011da <thdlr10>:
TRAPHANDLER(thdlr10, 10)
f01011da:	6a 0a                	push   $0xa
f01011dc:	e9 6e 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011e1:	90                   	nop

f01011e2 <thdlr11>:
TRAPHANDLER(thdlr11, 11)
f01011e2:	6a 0b                	push   $0xb
f01011e4:	e9 66 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011e9:	90                   	nop

f01011ea <thdlr12>:
TRAPHANDLER(thdlr12, 12)
f01011ea:	6a 0c                	push   $0xc
f01011ec:	e9 5e 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011f1:	90                   	nop

f01011f2 <thdlr13>:
TRAPHANDLER(thdlr13, 13)
f01011f2:	6a 0d                	push   $0xd
f01011f4:	e9 56 0a 00 00       	jmp    f0101c4f <_alltraps>
f01011f9:	90                   	nop

f01011fa <thdlr14>:
TRAPHANDLER(thdlr14, 14)
f01011fa:	6a 0e                	push   $0xe
f01011fc:	e9 4e 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101201:	90                   	nop

f0101202 <thdlr15>:
TRAPHANDLER_NOEC(thdlr15, 15)
f0101202:	6a 00                	push   $0x0
f0101204:	6a 0f                	push   $0xf
f0101206:	e9 44 0a 00 00       	jmp    f0101c4f <_alltraps>
f010120b:	90                   	nop

f010120c <thdlr16>:
TRAPHANDLER_NOEC(thdlr16, 16)
f010120c:	6a 00                	push   $0x0
f010120e:	6a 10                	push   $0x10
f0101210:	e9 3a 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101215:	90                   	nop

f0101216 <thdlr17>:
TRAPHANDLER(thdlr17, 17)
f0101216:	6a 11                	push   $0x11
f0101218:	e9 32 0a 00 00       	jmp    f0101c4f <_alltraps>
f010121d:	90                   	nop

f010121e <thdlr18>:
TRAPHANDLER_NOEC(thdlr18, 18)
f010121e:	6a 00                	push   $0x0
f0101220:	6a 12                	push   $0x12
f0101222:	e9 28 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101227:	90                   	nop

f0101228 <thdlr19>:
TRAPHANDLER_NOEC(thdlr19, 19)
f0101228:	6a 00                	push   $0x0
f010122a:	6a 13                	push   $0x13
f010122c:	e9 1e 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101231:	90                   	nop

f0101232 <thdlr20>:
TRAPHANDLER_NOEC(thdlr20, 20)
f0101232:	6a 00                	push   $0x0
f0101234:	6a 14                	push   $0x14
f0101236:	e9 14 0a 00 00       	jmp    f0101c4f <_alltraps>
f010123b:	90                   	nop

f010123c <thdlr21>:
TRAPHANDLER_NOEC(thdlr21, 21)
f010123c:	6a 00                	push   $0x0
f010123e:	6a 15                	push   $0x15
f0101240:	e9 0a 0a 00 00       	jmp    f0101c4f <_alltraps>
f0101245:	90                   	nop

f0101246 <thdlr22>:
TRAPHANDLER_NOEC(thdlr22, 22)
f0101246:	6a 00                	push   $0x0
f0101248:	6a 16                	push   $0x16
f010124a:	e9 00 0a 00 00       	jmp    f0101c4f <_alltraps>
f010124f:	90                   	nop

f0101250 <thdlr23>:
TRAPHANDLER_NOEC(thdlr23, 23)
f0101250:	6a 00                	push   $0x0
f0101252:	6a 17                	push   $0x17
f0101254:	e9 f6 09 00 00       	jmp    f0101c4f <_alltraps>
f0101259:	90                   	nop

f010125a <thdlr24>:
TRAPHANDLER_NOEC(thdlr24, 24)
f010125a:	6a 00                	push   $0x0
f010125c:	6a 18                	push   $0x18
f010125e:	e9 ec 09 00 00       	jmp    f0101c4f <_alltraps>
f0101263:	90                   	nop

f0101264 <thdlr25>:
TRAPHANDLER_NOEC(thdlr25, 25)
f0101264:	6a 00                	push   $0x0
f0101266:	6a 19                	push   $0x19
f0101268:	e9 e2 09 00 00       	jmp    f0101c4f <_alltraps>
f010126d:	90                   	nop

f010126e <thdlr26>:
TRAPHANDLER_NOEC(thdlr26, 26)
f010126e:	6a 00                	push   $0x0
f0101270:	6a 1a                	push   $0x1a
f0101272:	e9 d8 09 00 00       	jmp    f0101c4f <_alltraps>
f0101277:	90                   	nop

f0101278 <thdlr27>:
TRAPHANDLER_NOEC(thdlr27, 27)
f0101278:	6a 00                	push   $0x0
f010127a:	6a 1b                	push   $0x1b
f010127c:	e9 ce 09 00 00       	jmp    f0101c4f <_alltraps>
f0101281:	90                   	nop

f0101282 <thdlr28>:
TRAPHANDLER_NOEC(thdlr28, 28)
f0101282:	6a 00                	push   $0x0
f0101284:	6a 1c                	push   $0x1c
f0101286:	e9 c4 09 00 00       	jmp    f0101c4f <_alltraps>
f010128b:	90                   	nop

f010128c <thdlr29>:
TRAPHANDLER_NOEC(thdlr29, 29)
f010128c:	6a 00                	push   $0x0
f010128e:	6a 1d                	push   $0x1d
f0101290:	e9 ba 09 00 00       	jmp    f0101c4f <_alltraps>
f0101295:	90                   	nop

f0101296 <thdlr30>:
TRAPHANDLER_NOEC(thdlr30, 30)
f0101296:	6a 00                	push   $0x0
f0101298:	6a 1e                	push   $0x1e
f010129a:	e9 b0 09 00 00       	jmp    f0101c4f <_alltraps>
f010129f:	90                   	nop

f01012a0 <thdlr31>:
TRAPHANDLER_NOEC(thdlr31, 31)
f01012a0:	6a 00                	push   $0x0
f01012a2:	6a 1f                	push   $0x1f
f01012a4:	e9 a6 09 00 00       	jmp    f0101c4f <_alltraps>
f01012a9:	90                   	nop

f01012aa <thdlr32>:
TRAPHANDLER_NOEC(thdlr32, 32)
f01012aa:	6a 00                	push   $0x0
f01012ac:	6a 20                	push   $0x20
f01012ae:	e9 9c 09 00 00       	jmp    f0101c4f <_alltraps>
f01012b3:	90                   	nop

f01012b4 <thdlr33>:
TRAPHANDLER_NOEC(thdlr33, 33)
f01012b4:	6a 00                	push   $0x0
f01012b6:	6a 21                	push   $0x21
f01012b8:	e9 92 09 00 00       	jmp    f0101c4f <_alltraps>
f01012bd:	90                   	nop

f01012be <thdlr34>:
TRAPHANDLER_NOEC(thdlr34, 34)
f01012be:	6a 00                	push   $0x0
f01012c0:	6a 22                	push   $0x22
f01012c2:	e9 88 09 00 00       	jmp    f0101c4f <_alltraps>
f01012c7:	90                   	nop

f01012c8 <thdlr35>:
TRAPHANDLER_NOEC(thdlr35, 35)
f01012c8:	6a 00                	push   $0x0
f01012ca:	6a 23                	push   $0x23
f01012cc:	e9 7e 09 00 00       	jmp    f0101c4f <_alltraps>
f01012d1:	90                   	nop

f01012d2 <thdlr36>:
TRAPHANDLER_NOEC(thdlr36, 36)
f01012d2:	6a 00                	push   $0x0
f01012d4:	6a 24                	push   $0x24
f01012d6:	e9 74 09 00 00       	jmp    f0101c4f <_alltraps>
f01012db:	90                   	nop

f01012dc <thdlr37>:
TRAPHANDLER_NOEC(thdlr37, 37)
f01012dc:	6a 00                	push   $0x0
f01012de:	6a 25                	push   $0x25
f01012e0:	e9 6a 09 00 00       	jmp    f0101c4f <_alltraps>
f01012e5:	90                   	nop

f01012e6 <thdlr38>:
TRAPHANDLER_NOEC(thdlr38, 38)
f01012e6:	6a 00                	push   $0x0
f01012e8:	6a 26                	push   $0x26
f01012ea:	e9 60 09 00 00       	jmp    f0101c4f <_alltraps>
f01012ef:	90                   	nop

f01012f0 <thdlr39>:
TRAPHANDLER_NOEC(thdlr39, 39)
f01012f0:	6a 00                	push   $0x0
f01012f2:	6a 27                	push   $0x27
f01012f4:	e9 56 09 00 00       	jmp    f0101c4f <_alltraps>
f01012f9:	90                   	nop

f01012fa <thdlr40>:
TRAPHANDLER_NOEC(thdlr40, 40)
f01012fa:	6a 00                	push   $0x0
f01012fc:	6a 28                	push   $0x28
f01012fe:	e9 4c 09 00 00       	jmp    f0101c4f <_alltraps>
f0101303:	90                   	nop

f0101304 <thdlr41>:
TRAPHANDLER_NOEC(thdlr41, 41)
f0101304:	6a 00                	push   $0x0
f0101306:	6a 29                	push   $0x29
f0101308:	e9 42 09 00 00       	jmp    f0101c4f <_alltraps>
f010130d:	90                   	nop

f010130e <thdlr42>:
TRAPHANDLER_NOEC(thdlr42, 42)
f010130e:	6a 00                	push   $0x0
f0101310:	6a 2a                	push   $0x2a
f0101312:	e9 38 09 00 00       	jmp    f0101c4f <_alltraps>
f0101317:	90                   	nop

f0101318 <thdlr43>:
TRAPHANDLER_NOEC(thdlr43, 43)
f0101318:	6a 00                	push   $0x0
f010131a:	6a 2b                	push   $0x2b
f010131c:	e9 2e 09 00 00       	jmp    f0101c4f <_alltraps>
f0101321:	90                   	nop

f0101322 <thdlr44>:
TRAPHANDLER_NOEC(thdlr44, 44)
f0101322:	6a 00                	push   $0x0
f0101324:	6a 2c                	push   $0x2c
f0101326:	e9 24 09 00 00       	jmp    f0101c4f <_alltraps>
f010132b:	90                   	nop

f010132c <thdlr45>:
TRAPHANDLER_NOEC(thdlr45, 45)
f010132c:	6a 00                	push   $0x0
f010132e:	6a 2d                	push   $0x2d
f0101330:	e9 1a 09 00 00       	jmp    f0101c4f <_alltraps>
f0101335:	90                   	nop

f0101336 <thdlr46>:
TRAPHANDLER_NOEC(thdlr46, 46)
f0101336:	6a 00                	push   $0x0
f0101338:	6a 2e                	push   $0x2e
f010133a:	e9 10 09 00 00       	jmp    f0101c4f <_alltraps>
f010133f:	90                   	nop

f0101340 <thdlr47>:
TRAPHANDLER_NOEC(thdlr47, 47)
f0101340:	6a 00                	push   $0x0
f0101342:	6a 2f                	push   $0x2f
f0101344:	e9 06 09 00 00       	jmp    f0101c4f <_alltraps>
f0101349:	90                   	nop

f010134a <thdlr48>:
TRAPHANDLER_NOEC(thdlr48, 48)
f010134a:	6a 00                	push   $0x0
f010134c:	6a 30                	push   $0x30
f010134e:	e9 fc 08 00 00       	jmp    f0101c4f <_alltraps>
f0101353:	90                   	nop

f0101354 <thdlr49>:
TRAPHANDLER_NOEC(thdlr49, 49)
f0101354:	6a 00                	push   $0x0
f0101356:	6a 31                	push   $0x31
f0101358:	e9 f2 08 00 00       	jmp    f0101c4f <_alltraps>
f010135d:	90                   	nop

f010135e <thdlr50>:
TRAPHANDLER_NOEC(thdlr50, 50)
f010135e:	6a 00                	push   $0x0
f0101360:	6a 32                	push   $0x32
f0101362:	e9 e8 08 00 00       	jmp    f0101c4f <_alltraps>
f0101367:	90                   	nop

f0101368 <thdlr51>:
TRAPHANDLER_NOEC(thdlr51, 51)
f0101368:	6a 00                	push   $0x0
f010136a:	6a 33                	push   $0x33
f010136c:	e9 de 08 00 00       	jmp    f0101c4f <_alltraps>
f0101371:	90                   	nop

f0101372 <thdlr52>:
TRAPHANDLER_NOEC(thdlr52, 52)
f0101372:	6a 00                	push   $0x0
f0101374:	6a 34                	push   $0x34
f0101376:	e9 d4 08 00 00       	jmp    f0101c4f <_alltraps>
f010137b:	90                   	nop

f010137c <thdlr53>:
TRAPHANDLER_NOEC(thdlr53, 53)
f010137c:	6a 00                	push   $0x0
f010137e:	6a 35                	push   $0x35
f0101380:	e9 ca 08 00 00       	jmp    f0101c4f <_alltraps>
f0101385:	90                   	nop

f0101386 <thdlr54>:
TRAPHANDLER_NOEC(thdlr54, 54)
f0101386:	6a 00                	push   $0x0
f0101388:	6a 36                	push   $0x36
f010138a:	e9 c0 08 00 00       	jmp    f0101c4f <_alltraps>
f010138f:	90                   	nop

f0101390 <thdlr55>:
TRAPHANDLER_NOEC(thdlr55, 55)
f0101390:	6a 00                	push   $0x0
f0101392:	6a 37                	push   $0x37
f0101394:	e9 b6 08 00 00       	jmp    f0101c4f <_alltraps>
f0101399:	90                   	nop

f010139a <thdlr56>:
TRAPHANDLER_NOEC(thdlr56, 56)
f010139a:	6a 00                	push   $0x0
f010139c:	6a 38                	push   $0x38
f010139e:	e9 ac 08 00 00       	jmp    f0101c4f <_alltraps>
f01013a3:	90                   	nop

f01013a4 <thdlr57>:
TRAPHANDLER_NOEC(thdlr57, 57)
f01013a4:	6a 00                	push   $0x0
f01013a6:	6a 39                	push   $0x39
f01013a8:	e9 a2 08 00 00       	jmp    f0101c4f <_alltraps>
f01013ad:	90                   	nop

f01013ae <thdlr58>:
TRAPHANDLER_NOEC(thdlr58, 58)
f01013ae:	6a 00                	push   $0x0
f01013b0:	6a 3a                	push   $0x3a
f01013b2:	e9 98 08 00 00       	jmp    f0101c4f <_alltraps>
f01013b7:	90                   	nop

f01013b8 <thdlr59>:
TRAPHANDLER_NOEC(thdlr59, 59)
f01013b8:	6a 00                	push   $0x0
f01013ba:	6a 3b                	push   $0x3b
f01013bc:	e9 8e 08 00 00       	jmp    f0101c4f <_alltraps>
f01013c1:	90                   	nop

f01013c2 <thdlr60>:
TRAPHANDLER_NOEC(thdlr60, 60)
f01013c2:	6a 00                	push   $0x0
f01013c4:	6a 3c                	push   $0x3c
f01013c6:	e9 84 08 00 00       	jmp    f0101c4f <_alltraps>
f01013cb:	90                   	nop

f01013cc <thdlr61>:
TRAPHANDLER_NOEC(thdlr61, 61)
f01013cc:	6a 00                	push   $0x0
f01013ce:	6a 3d                	push   $0x3d
f01013d0:	e9 7a 08 00 00       	jmp    f0101c4f <_alltraps>
f01013d5:	90                   	nop

f01013d6 <thdlr62>:
TRAPHANDLER_NOEC(thdlr62, 62)
f01013d6:	6a 00                	push   $0x0
f01013d8:	6a 3e                	push   $0x3e
f01013da:	e9 70 08 00 00       	jmp    f0101c4f <_alltraps>
f01013df:	90                   	nop

f01013e0 <thdlr63>:
TRAPHANDLER_NOEC(thdlr63, 63)
f01013e0:	6a 00                	push   $0x0
f01013e2:	6a 3f                	push   $0x3f
f01013e4:	e9 66 08 00 00       	jmp    f0101c4f <_alltraps>
f01013e9:	90                   	nop

f01013ea <thdlr64>:
TRAPHANDLER_NOEC(thdlr64, 64)
f01013ea:	6a 00                	push   $0x0
f01013ec:	6a 40                	push   $0x40
f01013ee:	e9 5c 08 00 00       	jmp    f0101c4f <_alltraps>
f01013f3:	90                   	nop

f01013f4 <thdlr65>:
TRAPHANDLER_NOEC(thdlr65, 65)
f01013f4:	6a 00                	push   $0x0
f01013f6:	6a 41                	push   $0x41
f01013f8:	e9 52 08 00 00       	jmp    f0101c4f <_alltraps>
f01013fd:	90                   	nop

f01013fe <thdlr66>:
TRAPHANDLER_NOEC(thdlr66, 66)
f01013fe:	6a 00                	push   $0x0
f0101400:	6a 42                	push   $0x42
f0101402:	e9 48 08 00 00       	jmp    f0101c4f <_alltraps>
f0101407:	90                   	nop

f0101408 <thdlr67>:
TRAPHANDLER_NOEC(thdlr67, 67)
f0101408:	6a 00                	push   $0x0
f010140a:	6a 43                	push   $0x43
f010140c:	e9 3e 08 00 00       	jmp    f0101c4f <_alltraps>
f0101411:	90                   	nop

f0101412 <thdlr68>:
TRAPHANDLER_NOEC(thdlr68, 68)
f0101412:	6a 00                	push   $0x0
f0101414:	6a 44                	push   $0x44
f0101416:	e9 34 08 00 00       	jmp    f0101c4f <_alltraps>
f010141b:	90                   	nop

f010141c <thdlr69>:
TRAPHANDLER_NOEC(thdlr69, 69)
f010141c:	6a 00                	push   $0x0
f010141e:	6a 45                	push   $0x45
f0101420:	e9 2a 08 00 00       	jmp    f0101c4f <_alltraps>
f0101425:	90                   	nop

f0101426 <thdlr70>:
TRAPHANDLER_NOEC(thdlr70, 70)
f0101426:	6a 00                	push   $0x0
f0101428:	6a 46                	push   $0x46
f010142a:	e9 20 08 00 00       	jmp    f0101c4f <_alltraps>
f010142f:	90                   	nop

f0101430 <thdlr71>:
TRAPHANDLER_NOEC(thdlr71, 71)
f0101430:	6a 00                	push   $0x0
f0101432:	6a 47                	push   $0x47
f0101434:	e9 16 08 00 00       	jmp    f0101c4f <_alltraps>
f0101439:	90                   	nop

f010143a <thdlr72>:
TRAPHANDLER_NOEC(thdlr72, 72)
f010143a:	6a 00                	push   $0x0
f010143c:	6a 48                	push   $0x48
f010143e:	e9 0c 08 00 00       	jmp    f0101c4f <_alltraps>
f0101443:	90                   	nop

f0101444 <thdlr73>:
TRAPHANDLER_NOEC(thdlr73, 73)
f0101444:	6a 00                	push   $0x0
f0101446:	6a 49                	push   $0x49
f0101448:	e9 02 08 00 00       	jmp    f0101c4f <_alltraps>
f010144d:	90                   	nop

f010144e <thdlr74>:
TRAPHANDLER_NOEC(thdlr74, 74)
f010144e:	6a 00                	push   $0x0
f0101450:	6a 4a                	push   $0x4a
f0101452:	e9 f8 07 00 00       	jmp    f0101c4f <_alltraps>
f0101457:	90                   	nop

f0101458 <thdlr75>:
TRAPHANDLER_NOEC(thdlr75, 75)
f0101458:	6a 00                	push   $0x0
f010145a:	6a 4b                	push   $0x4b
f010145c:	e9 ee 07 00 00       	jmp    f0101c4f <_alltraps>
f0101461:	90                   	nop

f0101462 <thdlr76>:
TRAPHANDLER_NOEC(thdlr76, 76)
f0101462:	6a 00                	push   $0x0
f0101464:	6a 4c                	push   $0x4c
f0101466:	e9 e4 07 00 00       	jmp    f0101c4f <_alltraps>
f010146b:	90                   	nop

f010146c <thdlr77>:
TRAPHANDLER_NOEC(thdlr77, 77)
f010146c:	6a 00                	push   $0x0
f010146e:	6a 4d                	push   $0x4d
f0101470:	e9 da 07 00 00       	jmp    f0101c4f <_alltraps>
f0101475:	90                   	nop

f0101476 <thdlr78>:
TRAPHANDLER_NOEC(thdlr78, 78)
f0101476:	6a 00                	push   $0x0
f0101478:	6a 4e                	push   $0x4e
f010147a:	e9 d0 07 00 00       	jmp    f0101c4f <_alltraps>
f010147f:	90                   	nop

f0101480 <thdlr79>:
TRAPHANDLER_NOEC(thdlr79, 79)
f0101480:	6a 00                	push   $0x0
f0101482:	6a 4f                	push   $0x4f
f0101484:	e9 c6 07 00 00       	jmp    f0101c4f <_alltraps>
f0101489:	90                   	nop

f010148a <thdlr80>:
TRAPHANDLER_NOEC(thdlr80, 80)
f010148a:	6a 00                	push   $0x0
f010148c:	6a 50                	push   $0x50
f010148e:	e9 bc 07 00 00       	jmp    f0101c4f <_alltraps>
f0101493:	90                   	nop

f0101494 <thdlr81>:
TRAPHANDLER_NOEC(thdlr81, 81)
f0101494:	6a 00                	push   $0x0
f0101496:	6a 51                	push   $0x51
f0101498:	e9 b2 07 00 00       	jmp    f0101c4f <_alltraps>
f010149d:	90                   	nop

f010149e <thdlr82>:
TRAPHANDLER_NOEC(thdlr82, 82)
f010149e:	6a 00                	push   $0x0
f01014a0:	6a 52                	push   $0x52
f01014a2:	e9 a8 07 00 00       	jmp    f0101c4f <_alltraps>
f01014a7:	90                   	nop

f01014a8 <thdlr83>:
TRAPHANDLER_NOEC(thdlr83, 83)
f01014a8:	6a 00                	push   $0x0
f01014aa:	6a 53                	push   $0x53
f01014ac:	e9 9e 07 00 00       	jmp    f0101c4f <_alltraps>
f01014b1:	90                   	nop

f01014b2 <thdlr84>:
TRAPHANDLER_NOEC(thdlr84, 84)
f01014b2:	6a 00                	push   $0x0
f01014b4:	6a 54                	push   $0x54
f01014b6:	e9 94 07 00 00       	jmp    f0101c4f <_alltraps>
f01014bb:	90                   	nop

f01014bc <thdlr85>:
TRAPHANDLER_NOEC(thdlr85, 85)
f01014bc:	6a 00                	push   $0x0
f01014be:	6a 55                	push   $0x55
f01014c0:	e9 8a 07 00 00       	jmp    f0101c4f <_alltraps>
f01014c5:	90                   	nop

f01014c6 <thdlr86>:
TRAPHANDLER_NOEC(thdlr86, 86)
f01014c6:	6a 00                	push   $0x0
f01014c8:	6a 56                	push   $0x56
f01014ca:	e9 80 07 00 00       	jmp    f0101c4f <_alltraps>
f01014cf:	90                   	nop

f01014d0 <thdlr87>:
TRAPHANDLER_NOEC(thdlr87, 87)
f01014d0:	6a 00                	push   $0x0
f01014d2:	6a 57                	push   $0x57
f01014d4:	e9 76 07 00 00       	jmp    f0101c4f <_alltraps>
f01014d9:	90                   	nop

f01014da <thdlr88>:
TRAPHANDLER_NOEC(thdlr88, 88)
f01014da:	6a 00                	push   $0x0
f01014dc:	6a 58                	push   $0x58
f01014de:	e9 6c 07 00 00       	jmp    f0101c4f <_alltraps>
f01014e3:	90                   	nop

f01014e4 <thdlr89>:
TRAPHANDLER_NOEC(thdlr89, 89)
f01014e4:	6a 00                	push   $0x0
f01014e6:	6a 59                	push   $0x59
f01014e8:	e9 62 07 00 00       	jmp    f0101c4f <_alltraps>
f01014ed:	90                   	nop

f01014ee <thdlr90>:
TRAPHANDLER_NOEC(thdlr90, 90)
f01014ee:	6a 00                	push   $0x0
f01014f0:	6a 5a                	push   $0x5a
f01014f2:	e9 58 07 00 00       	jmp    f0101c4f <_alltraps>
f01014f7:	90                   	nop

f01014f8 <thdlr91>:
TRAPHANDLER_NOEC(thdlr91, 91)
f01014f8:	6a 00                	push   $0x0
f01014fa:	6a 5b                	push   $0x5b
f01014fc:	e9 4e 07 00 00       	jmp    f0101c4f <_alltraps>
f0101501:	90                   	nop

f0101502 <thdlr92>:
TRAPHANDLER_NOEC(thdlr92, 92)
f0101502:	6a 00                	push   $0x0
f0101504:	6a 5c                	push   $0x5c
f0101506:	e9 44 07 00 00       	jmp    f0101c4f <_alltraps>
f010150b:	90                   	nop

f010150c <thdlr93>:
TRAPHANDLER_NOEC(thdlr93, 93)
f010150c:	6a 00                	push   $0x0
f010150e:	6a 5d                	push   $0x5d
f0101510:	e9 3a 07 00 00       	jmp    f0101c4f <_alltraps>
f0101515:	90                   	nop

f0101516 <thdlr94>:
TRAPHANDLER_NOEC(thdlr94, 94)
f0101516:	6a 00                	push   $0x0
f0101518:	6a 5e                	push   $0x5e
f010151a:	e9 30 07 00 00       	jmp    f0101c4f <_alltraps>
f010151f:	90                   	nop

f0101520 <thdlr95>:
TRAPHANDLER_NOEC(thdlr95, 95)
f0101520:	6a 00                	push   $0x0
f0101522:	6a 5f                	push   $0x5f
f0101524:	e9 26 07 00 00       	jmp    f0101c4f <_alltraps>
f0101529:	90                   	nop

f010152a <thdlr96>:
TRAPHANDLER_NOEC(thdlr96, 96)
f010152a:	6a 00                	push   $0x0
f010152c:	6a 60                	push   $0x60
f010152e:	e9 1c 07 00 00       	jmp    f0101c4f <_alltraps>
f0101533:	90                   	nop

f0101534 <thdlr97>:
TRAPHANDLER_NOEC(thdlr97, 97)
f0101534:	6a 00                	push   $0x0
f0101536:	6a 61                	push   $0x61
f0101538:	e9 12 07 00 00       	jmp    f0101c4f <_alltraps>
f010153d:	90                   	nop

f010153e <thdlr98>:
TRAPHANDLER_NOEC(thdlr98, 98)
f010153e:	6a 00                	push   $0x0
f0101540:	6a 62                	push   $0x62
f0101542:	e9 08 07 00 00       	jmp    f0101c4f <_alltraps>
f0101547:	90                   	nop

f0101548 <thdlr99>:
TRAPHANDLER_NOEC(thdlr99, 99)
f0101548:	6a 00                	push   $0x0
f010154a:	6a 63                	push   $0x63
f010154c:	e9 fe 06 00 00       	jmp    f0101c4f <_alltraps>
f0101551:	90                   	nop

f0101552 <thdlr100>:
TRAPHANDLER_NOEC(thdlr100, 100)
f0101552:	6a 00                	push   $0x0
f0101554:	6a 64                	push   $0x64
f0101556:	e9 f4 06 00 00       	jmp    f0101c4f <_alltraps>
f010155b:	90                   	nop

f010155c <thdlr101>:
TRAPHANDLER_NOEC(thdlr101, 101)
f010155c:	6a 00                	push   $0x0
f010155e:	6a 65                	push   $0x65
f0101560:	e9 ea 06 00 00       	jmp    f0101c4f <_alltraps>
f0101565:	90                   	nop

f0101566 <thdlr102>:
TRAPHANDLER_NOEC(thdlr102, 102)
f0101566:	6a 00                	push   $0x0
f0101568:	6a 66                	push   $0x66
f010156a:	e9 e0 06 00 00       	jmp    f0101c4f <_alltraps>
f010156f:	90                   	nop

f0101570 <thdlr103>:
TRAPHANDLER_NOEC(thdlr103, 103)
f0101570:	6a 00                	push   $0x0
f0101572:	6a 67                	push   $0x67
f0101574:	e9 d6 06 00 00       	jmp    f0101c4f <_alltraps>
f0101579:	90                   	nop

f010157a <thdlr104>:
TRAPHANDLER_NOEC(thdlr104, 104)
f010157a:	6a 00                	push   $0x0
f010157c:	6a 68                	push   $0x68
f010157e:	e9 cc 06 00 00       	jmp    f0101c4f <_alltraps>
f0101583:	90                   	nop

f0101584 <thdlr105>:
TRAPHANDLER_NOEC(thdlr105, 105)
f0101584:	6a 00                	push   $0x0
f0101586:	6a 69                	push   $0x69
f0101588:	e9 c2 06 00 00       	jmp    f0101c4f <_alltraps>
f010158d:	90                   	nop

f010158e <thdlr106>:
TRAPHANDLER_NOEC(thdlr106, 106)
f010158e:	6a 00                	push   $0x0
f0101590:	6a 6a                	push   $0x6a
f0101592:	e9 b8 06 00 00       	jmp    f0101c4f <_alltraps>
f0101597:	90                   	nop

f0101598 <thdlr107>:
TRAPHANDLER_NOEC(thdlr107, 107)
f0101598:	6a 00                	push   $0x0
f010159a:	6a 6b                	push   $0x6b
f010159c:	e9 ae 06 00 00       	jmp    f0101c4f <_alltraps>
f01015a1:	90                   	nop

f01015a2 <thdlr108>:
TRAPHANDLER_NOEC(thdlr108, 108)
f01015a2:	6a 00                	push   $0x0
f01015a4:	6a 6c                	push   $0x6c
f01015a6:	e9 a4 06 00 00       	jmp    f0101c4f <_alltraps>
f01015ab:	90                   	nop

f01015ac <thdlr109>:
TRAPHANDLER_NOEC(thdlr109, 109)
f01015ac:	6a 00                	push   $0x0
f01015ae:	6a 6d                	push   $0x6d
f01015b0:	e9 9a 06 00 00       	jmp    f0101c4f <_alltraps>
f01015b5:	90                   	nop

f01015b6 <thdlr110>:
TRAPHANDLER_NOEC(thdlr110, 110)
f01015b6:	6a 00                	push   $0x0
f01015b8:	6a 6e                	push   $0x6e
f01015ba:	e9 90 06 00 00       	jmp    f0101c4f <_alltraps>
f01015bf:	90                   	nop

f01015c0 <thdlr111>:
TRAPHANDLER_NOEC(thdlr111, 111)
f01015c0:	6a 00                	push   $0x0
f01015c2:	6a 6f                	push   $0x6f
f01015c4:	e9 86 06 00 00       	jmp    f0101c4f <_alltraps>
f01015c9:	90                   	nop

f01015ca <thdlr112>:
TRAPHANDLER_NOEC(thdlr112, 112)
f01015ca:	6a 00                	push   $0x0
f01015cc:	6a 70                	push   $0x70
f01015ce:	e9 7c 06 00 00       	jmp    f0101c4f <_alltraps>
f01015d3:	90                   	nop

f01015d4 <thdlr113>:
TRAPHANDLER_NOEC(thdlr113, 113)
f01015d4:	6a 00                	push   $0x0
f01015d6:	6a 71                	push   $0x71
f01015d8:	e9 72 06 00 00       	jmp    f0101c4f <_alltraps>
f01015dd:	90                   	nop

f01015de <thdlr114>:
TRAPHANDLER_NOEC(thdlr114, 114)
f01015de:	6a 00                	push   $0x0
f01015e0:	6a 72                	push   $0x72
f01015e2:	e9 68 06 00 00       	jmp    f0101c4f <_alltraps>
f01015e7:	90                   	nop

f01015e8 <thdlr115>:
TRAPHANDLER_NOEC(thdlr115, 115)
f01015e8:	6a 00                	push   $0x0
f01015ea:	6a 73                	push   $0x73
f01015ec:	e9 5e 06 00 00       	jmp    f0101c4f <_alltraps>
f01015f1:	90                   	nop

f01015f2 <thdlr116>:
TRAPHANDLER_NOEC(thdlr116, 116)
f01015f2:	6a 00                	push   $0x0
f01015f4:	6a 74                	push   $0x74
f01015f6:	e9 54 06 00 00       	jmp    f0101c4f <_alltraps>
f01015fb:	90                   	nop

f01015fc <thdlr117>:
TRAPHANDLER_NOEC(thdlr117, 117)
f01015fc:	6a 00                	push   $0x0
f01015fe:	6a 75                	push   $0x75
f0101600:	e9 4a 06 00 00       	jmp    f0101c4f <_alltraps>
f0101605:	90                   	nop

f0101606 <thdlr118>:
TRAPHANDLER_NOEC(thdlr118, 118)
f0101606:	6a 00                	push   $0x0
f0101608:	6a 76                	push   $0x76
f010160a:	e9 40 06 00 00       	jmp    f0101c4f <_alltraps>
f010160f:	90                   	nop

f0101610 <thdlr119>:
TRAPHANDLER_NOEC(thdlr119, 119)
f0101610:	6a 00                	push   $0x0
f0101612:	6a 77                	push   $0x77
f0101614:	e9 36 06 00 00       	jmp    f0101c4f <_alltraps>
f0101619:	90                   	nop

f010161a <thdlr120>:
TRAPHANDLER_NOEC(thdlr120, 120)
f010161a:	6a 00                	push   $0x0
f010161c:	6a 78                	push   $0x78
f010161e:	e9 2c 06 00 00       	jmp    f0101c4f <_alltraps>
f0101623:	90                   	nop

f0101624 <thdlr121>:
TRAPHANDLER_NOEC(thdlr121, 121)
f0101624:	6a 00                	push   $0x0
f0101626:	6a 79                	push   $0x79
f0101628:	e9 22 06 00 00       	jmp    f0101c4f <_alltraps>
f010162d:	90                   	nop

f010162e <thdlr122>:
TRAPHANDLER_NOEC(thdlr122, 122)
f010162e:	6a 00                	push   $0x0
f0101630:	6a 7a                	push   $0x7a
f0101632:	e9 18 06 00 00       	jmp    f0101c4f <_alltraps>
f0101637:	90                   	nop

f0101638 <thdlr123>:
TRAPHANDLER_NOEC(thdlr123, 123)
f0101638:	6a 00                	push   $0x0
f010163a:	6a 7b                	push   $0x7b
f010163c:	e9 0e 06 00 00       	jmp    f0101c4f <_alltraps>
f0101641:	90                   	nop

f0101642 <thdlr124>:
TRAPHANDLER_NOEC(thdlr124, 124)
f0101642:	6a 00                	push   $0x0
f0101644:	6a 7c                	push   $0x7c
f0101646:	e9 04 06 00 00       	jmp    f0101c4f <_alltraps>
f010164b:	90                   	nop

f010164c <thdlr125>:
TRAPHANDLER_NOEC(thdlr125, 125)
f010164c:	6a 00                	push   $0x0
f010164e:	6a 7d                	push   $0x7d
f0101650:	e9 fa 05 00 00       	jmp    f0101c4f <_alltraps>
f0101655:	90                   	nop

f0101656 <thdlr126>:
TRAPHANDLER_NOEC(thdlr126, 126)
f0101656:	6a 00                	push   $0x0
f0101658:	6a 7e                	push   $0x7e
f010165a:	e9 f0 05 00 00       	jmp    f0101c4f <_alltraps>
f010165f:	90                   	nop

f0101660 <thdlr127>:
TRAPHANDLER_NOEC(thdlr127, 127)
f0101660:	6a 00                	push   $0x0
f0101662:	6a 7f                	push   $0x7f
f0101664:	e9 e6 05 00 00       	jmp    f0101c4f <_alltraps>
f0101669:	90                   	nop

f010166a <thdlr128>:
TRAPHANDLER_NOEC(thdlr128, 128)
f010166a:	6a 00                	push   $0x0
f010166c:	68 80 00 00 00       	push   $0x80
f0101671:	e9 d9 05 00 00       	jmp    f0101c4f <_alltraps>

f0101676 <thdlr129>:
TRAPHANDLER_NOEC(thdlr129, 129)
f0101676:	6a 00                	push   $0x0
f0101678:	68 81 00 00 00       	push   $0x81
f010167d:	e9 cd 05 00 00       	jmp    f0101c4f <_alltraps>

f0101682 <thdlr130>:
TRAPHANDLER_NOEC(thdlr130, 130)
f0101682:	6a 00                	push   $0x0
f0101684:	68 82 00 00 00       	push   $0x82
f0101689:	e9 c1 05 00 00       	jmp    f0101c4f <_alltraps>

f010168e <thdlr131>:
TRAPHANDLER_NOEC(thdlr131, 131)
f010168e:	6a 00                	push   $0x0
f0101690:	68 83 00 00 00       	push   $0x83
f0101695:	e9 b5 05 00 00       	jmp    f0101c4f <_alltraps>

f010169a <thdlr132>:
TRAPHANDLER_NOEC(thdlr132, 132)
f010169a:	6a 00                	push   $0x0
f010169c:	68 84 00 00 00       	push   $0x84
f01016a1:	e9 a9 05 00 00       	jmp    f0101c4f <_alltraps>

f01016a6 <thdlr133>:
TRAPHANDLER_NOEC(thdlr133, 133)
f01016a6:	6a 00                	push   $0x0
f01016a8:	68 85 00 00 00       	push   $0x85
f01016ad:	e9 9d 05 00 00       	jmp    f0101c4f <_alltraps>

f01016b2 <thdlr134>:
TRAPHANDLER_NOEC(thdlr134, 134)
f01016b2:	6a 00                	push   $0x0
f01016b4:	68 86 00 00 00       	push   $0x86
f01016b9:	e9 91 05 00 00       	jmp    f0101c4f <_alltraps>

f01016be <thdlr135>:
TRAPHANDLER_NOEC(thdlr135, 135)
f01016be:	6a 00                	push   $0x0
f01016c0:	68 87 00 00 00       	push   $0x87
f01016c5:	e9 85 05 00 00       	jmp    f0101c4f <_alltraps>

f01016ca <thdlr136>:
TRAPHANDLER_NOEC(thdlr136, 136)
f01016ca:	6a 00                	push   $0x0
f01016cc:	68 88 00 00 00       	push   $0x88
f01016d1:	e9 79 05 00 00       	jmp    f0101c4f <_alltraps>

f01016d6 <thdlr137>:
TRAPHANDLER_NOEC(thdlr137, 137)
f01016d6:	6a 00                	push   $0x0
f01016d8:	68 89 00 00 00       	push   $0x89
f01016dd:	e9 6d 05 00 00       	jmp    f0101c4f <_alltraps>

f01016e2 <thdlr138>:
TRAPHANDLER_NOEC(thdlr138, 138)
f01016e2:	6a 00                	push   $0x0
f01016e4:	68 8a 00 00 00       	push   $0x8a
f01016e9:	e9 61 05 00 00       	jmp    f0101c4f <_alltraps>

f01016ee <thdlr139>:
TRAPHANDLER_NOEC(thdlr139, 139)
f01016ee:	6a 00                	push   $0x0
f01016f0:	68 8b 00 00 00       	push   $0x8b
f01016f5:	e9 55 05 00 00       	jmp    f0101c4f <_alltraps>

f01016fa <thdlr140>:
TRAPHANDLER_NOEC(thdlr140, 140)
f01016fa:	6a 00                	push   $0x0
f01016fc:	68 8c 00 00 00       	push   $0x8c
f0101701:	e9 49 05 00 00       	jmp    f0101c4f <_alltraps>

f0101706 <thdlr141>:
TRAPHANDLER_NOEC(thdlr141, 141)
f0101706:	6a 00                	push   $0x0
f0101708:	68 8d 00 00 00       	push   $0x8d
f010170d:	e9 3d 05 00 00       	jmp    f0101c4f <_alltraps>

f0101712 <thdlr142>:
TRAPHANDLER_NOEC(thdlr142, 142)
f0101712:	6a 00                	push   $0x0
f0101714:	68 8e 00 00 00       	push   $0x8e
f0101719:	e9 31 05 00 00       	jmp    f0101c4f <_alltraps>

f010171e <thdlr143>:
TRAPHANDLER_NOEC(thdlr143, 143)
f010171e:	6a 00                	push   $0x0
f0101720:	68 8f 00 00 00       	push   $0x8f
f0101725:	e9 25 05 00 00       	jmp    f0101c4f <_alltraps>

f010172a <thdlr144>:
TRAPHANDLER_NOEC(thdlr144, 144)
f010172a:	6a 00                	push   $0x0
f010172c:	68 90 00 00 00       	push   $0x90
f0101731:	e9 19 05 00 00       	jmp    f0101c4f <_alltraps>

f0101736 <thdlr145>:
TRAPHANDLER_NOEC(thdlr145, 145)
f0101736:	6a 00                	push   $0x0
f0101738:	68 91 00 00 00       	push   $0x91
f010173d:	e9 0d 05 00 00       	jmp    f0101c4f <_alltraps>

f0101742 <thdlr146>:
TRAPHANDLER_NOEC(thdlr146, 146)
f0101742:	6a 00                	push   $0x0
f0101744:	68 92 00 00 00       	push   $0x92
f0101749:	e9 01 05 00 00       	jmp    f0101c4f <_alltraps>

f010174e <thdlr147>:
TRAPHANDLER_NOEC(thdlr147, 147)
f010174e:	6a 00                	push   $0x0
f0101750:	68 93 00 00 00       	push   $0x93
f0101755:	e9 f5 04 00 00       	jmp    f0101c4f <_alltraps>

f010175a <thdlr148>:
TRAPHANDLER_NOEC(thdlr148, 148)
f010175a:	6a 00                	push   $0x0
f010175c:	68 94 00 00 00       	push   $0x94
f0101761:	e9 e9 04 00 00       	jmp    f0101c4f <_alltraps>

f0101766 <thdlr149>:
TRAPHANDLER_NOEC(thdlr149, 149)
f0101766:	6a 00                	push   $0x0
f0101768:	68 95 00 00 00       	push   $0x95
f010176d:	e9 dd 04 00 00       	jmp    f0101c4f <_alltraps>

f0101772 <thdlr150>:
TRAPHANDLER_NOEC(thdlr150, 150)
f0101772:	6a 00                	push   $0x0
f0101774:	68 96 00 00 00       	push   $0x96
f0101779:	e9 d1 04 00 00       	jmp    f0101c4f <_alltraps>

f010177e <thdlr151>:
TRAPHANDLER_NOEC(thdlr151, 151)
f010177e:	6a 00                	push   $0x0
f0101780:	68 97 00 00 00       	push   $0x97
f0101785:	e9 c5 04 00 00       	jmp    f0101c4f <_alltraps>

f010178a <thdlr152>:
TRAPHANDLER_NOEC(thdlr152, 152)
f010178a:	6a 00                	push   $0x0
f010178c:	68 98 00 00 00       	push   $0x98
f0101791:	e9 b9 04 00 00       	jmp    f0101c4f <_alltraps>

f0101796 <thdlr153>:
TRAPHANDLER_NOEC(thdlr153, 153)
f0101796:	6a 00                	push   $0x0
f0101798:	68 99 00 00 00       	push   $0x99
f010179d:	e9 ad 04 00 00       	jmp    f0101c4f <_alltraps>

f01017a2 <thdlr154>:
TRAPHANDLER_NOEC(thdlr154, 154)
f01017a2:	6a 00                	push   $0x0
f01017a4:	68 9a 00 00 00       	push   $0x9a
f01017a9:	e9 a1 04 00 00       	jmp    f0101c4f <_alltraps>

f01017ae <thdlr155>:
TRAPHANDLER_NOEC(thdlr155, 155)
f01017ae:	6a 00                	push   $0x0
f01017b0:	68 9b 00 00 00       	push   $0x9b
f01017b5:	e9 95 04 00 00       	jmp    f0101c4f <_alltraps>

f01017ba <thdlr156>:
TRAPHANDLER_NOEC(thdlr156, 156)
f01017ba:	6a 00                	push   $0x0
f01017bc:	68 9c 00 00 00       	push   $0x9c
f01017c1:	e9 89 04 00 00       	jmp    f0101c4f <_alltraps>

f01017c6 <thdlr157>:
TRAPHANDLER_NOEC(thdlr157, 157)
f01017c6:	6a 00                	push   $0x0
f01017c8:	68 9d 00 00 00       	push   $0x9d
f01017cd:	e9 7d 04 00 00       	jmp    f0101c4f <_alltraps>

f01017d2 <thdlr158>:
TRAPHANDLER_NOEC(thdlr158, 158)
f01017d2:	6a 00                	push   $0x0
f01017d4:	68 9e 00 00 00       	push   $0x9e
f01017d9:	e9 71 04 00 00       	jmp    f0101c4f <_alltraps>

f01017de <thdlr159>:
TRAPHANDLER_NOEC(thdlr159, 159)
f01017de:	6a 00                	push   $0x0
f01017e0:	68 9f 00 00 00       	push   $0x9f
f01017e5:	e9 65 04 00 00       	jmp    f0101c4f <_alltraps>

f01017ea <thdlr160>:
TRAPHANDLER_NOEC(thdlr160, 160)
f01017ea:	6a 00                	push   $0x0
f01017ec:	68 a0 00 00 00       	push   $0xa0
f01017f1:	e9 59 04 00 00       	jmp    f0101c4f <_alltraps>

f01017f6 <thdlr161>:
TRAPHANDLER_NOEC(thdlr161, 161)
f01017f6:	6a 00                	push   $0x0
f01017f8:	68 a1 00 00 00       	push   $0xa1
f01017fd:	e9 4d 04 00 00       	jmp    f0101c4f <_alltraps>

f0101802 <thdlr162>:
TRAPHANDLER_NOEC(thdlr162, 162)
f0101802:	6a 00                	push   $0x0
f0101804:	68 a2 00 00 00       	push   $0xa2
f0101809:	e9 41 04 00 00       	jmp    f0101c4f <_alltraps>

f010180e <thdlr163>:
TRAPHANDLER_NOEC(thdlr163, 163)
f010180e:	6a 00                	push   $0x0
f0101810:	68 a3 00 00 00       	push   $0xa3
f0101815:	e9 35 04 00 00       	jmp    f0101c4f <_alltraps>

f010181a <thdlr164>:
TRAPHANDLER_NOEC(thdlr164, 164)
f010181a:	6a 00                	push   $0x0
f010181c:	68 a4 00 00 00       	push   $0xa4
f0101821:	e9 29 04 00 00       	jmp    f0101c4f <_alltraps>

f0101826 <thdlr165>:
TRAPHANDLER_NOEC(thdlr165, 165)
f0101826:	6a 00                	push   $0x0
f0101828:	68 a5 00 00 00       	push   $0xa5
f010182d:	e9 1d 04 00 00       	jmp    f0101c4f <_alltraps>

f0101832 <thdlr166>:
TRAPHANDLER_NOEC(thdlr166, 166)
f0101832:	6a 00                	push   $0x0
f0101834:	68 a6 00 00 00       	push   $0xa6
f0101839:	e9 11 04 00 00       	jmp    f0101c4f <_alltraps>

f010183e <thdlr167>:
TRAPHANDLER_NOEC(thdlr167, 167)
f010183e:	6a 00                	push   $0x0
f0101840:	68 a7 00 00 00       	push   $0xa7
f0101845:	e9 05 04 00 00       	jmp    f0101c4f <_alltraps>

f010184a <thdlr168>:
TRAPHANDLER_NOEC(thdlr168, 168)
f010184a:	6a 00                	push   $0x0
f010184c:	68 a8 00 00 00       	push   $0xa8
f0101851:	e9 f9 03 00 00       	jmp    f0101c4f <_alltraps>

f0101856 <thdlr169>:
TRAPHANDLER_NOEC(thdlr169, 169)
f0101856:	6a 00                	push   $0x0
f0101858:	68 a9 00 00 00       	push   $0xa9
f010185d:	e9 ed 03 00 00       	jmp    f0101c4f <_alltraps>

f0101862 <thdlr170>:
TRAPHANDLER_NOEC(thdlr170, 170)
f0101862:	6a 00                	push   $0x0
f0101864:	68 aa 00 00 00       	push   $0xaa
f0101869:	e9 e1 03 00 00       	jmp    f0101c4f <_alltraps>

f010186e <thdlr171>:
TRAPHANDLER_NOEC(thdlr171, 171)
f010186e:	6a 00                	push   $0x0
f0101870:	68 ab 00 00 00       	push   $0xab
f0101875:	e9 d5 03 00 00       	jmp    f0101c4f <_alltraps>

f010187a <thdlr172>:
TRAPHANDLER_NOEC(thdlr172, 172)
f010187a:	6a 00                	push   $0x0
f010187c:	68 ac 00 00 00       	push   $0xac
f0101881:	e9 c9 03 00 00       	jmp    f0101c4f <_alltraps>

f0101886 <thdlr173>:
TRAPHANDLER_NOEC(thdlr173, 173)
f0101886:	6a 00                	push   $0x0
f0101888:	68 ad 00 00 00       	push   $0xad
f010188d:	e9 bd 03 00 00       	jmp    f0101c4f <_alltraps>

f0101892 <thdlr174>:
TRAPHANDLER_NOEC(thdlr174, 174)
f0101892:	6a 00                	push   $0x0
f0101894:	68 ae 00 00 00       	push   $0xae
f0101899:	e9 b1 03 00 00       	jmp    f0101c4f <_alltraps>

f010189e <thdlr175>:
TRAPHANDLER_NOEC(thdlr175, 175)
f010189e:	6a 00                	push   $0x0
f01018a0:	68 af 00 00 00       	push   $0xaf
f01018a5:	e9 a5 03 00 00       	jmp    f0101c4f <_alltraps>

f01018aa <thdlr176>:
TRAPHANDLER_NOEC(thdlr176, 176)
f01018aa:	6a 00                	push   $0x0
f01018ac:	68 b0 00 00 00       	push   $0xb0
f01018b1:	e9 99 03 00 00       	jmp    f0101c4f <_alltraps>

f01018b6 <thdlr177>:
TRAPHANDLER_NOEC(thdlr177, 177)
f01018b6:	6a 00                	push   $0x0
f01018b8:	68 b1 00 00 00       	push   $0xb1
f01018bd:	e9 8d 03 00 00       	jmp    f0101c4f <_alltraps>

f01018c2 <thdlr178>:
TRAPHANDLER_NOEC(thdlr178, 178)
f01018c2:	6a 00                	push   $0x0
f01018c4:	68 b2 00 00 00       	push   $0xb2
f01018c9:	e9 81 03 00 00       	jmp    f0101c4f <_alltraps>

f01018ce <thdlr179>:
TRAPHANDLER_NOEC(thdlr179, 179)
f01018ce:	6a 00                	push   $0x0
f01018d0:	68 b3 00 00 00       	push   $0xb3
f01018d5:	e9 75 03 00 00       	jmp    f0101c4f <_alltraps>

f01018da <thdlr180>:
TRAPHANDLER_NOEC(thdlr180, 180)
f01018da:	6a 00                	push   $0x0
f01018dc:	68 b4 00 00 00       	push   $0xb4
f01018e1:	e9 69 03 00 00       	jmp    f0101c4f <_alltraps>

f01018e6 <thdlr181>:
TRAPHANDLER_NOEC(thdlr181, 181)
f01018e6:	6a 00                	push   $0x0
f01018e8:	68 b5 00 00 00       	push   $0xb5
f01018ed:	e9 5d 03 00 00       	jmp    f0101c4f <_alltraps>

f01018f2 <thdlr182>:
TRAPHANDLER_NOEC(thdlr182, 182)
f01018f2:	6a 00                	push   $0x0
f01018f4:	68 b6 00 00 00       	push   $0xb6
f01018f9:	e9 51 03 00 00       	jmp    f0101c4f <_alltraps>

f01018fe <thdlr183>:
TRAPHANDLER_NOEC(thdlr183, 183)
f01018fe:	6a 00                	push   $0x0
f0101900:	68 b7 00 00 00       	push   $0xb7
f0101905:	e9 45 03 00 00       	jmp    f0101c4f <_alltraps>

f010190a <thdlr184>:
TRAPHANDLER_NOEC(thdlr184, 184)
f010190a:	6a 00                	push   $0x0
f010190c:	68 b8 00 00 00       	push   $0xb8
f0101911:	e9 39 03 00 00       	jmp    f0101c4f <_alltraps>

f0101916 <thdlr185>:
TRAPHANDLER_NOEC(thdlr185, 185)
f0101916:	6a 00                	push   $0x0
f0101918:	68 b9 00 00 00       	push   $0xb9
f010191d:	e9 2d 03 00 00       	jmp    f0101c4f <_alltraps>

f0101922 <thdlr186>:
TRAPHANDLER_NOEC(thdlr186, 186)
f0101922:	6a 00                	push   $0x0
f0101924:	68 ba 00 00 00       	push   $0xba
f0101929:	e9 21 03 00 00       	jmp    f0101c4f <_alltraps>

f010192e <thdlr187>:
TRAPHANDLER_NOEC(thdlr187, 187)
f010192e:	6a 00                	push   $0x0
f0101930:	68 bb 00 00 00       	push   $0xbb
f0101935:	e9 15 03 00 00       	jmp    f0101c4f <_alltraps>

f010193a <thdlr188>:
TRAPHANDLER_NOEC(thdlr188, 188)
f010193a:	6a 00                	push   $0x0
f010193c:	68 bc 00 00 00       	push   $0xbc
f0101941:	e9 09 03 00 00       	jmp    f0101c4f <_alltraps>

f0101946 <thdlr189>:
TRAPHANDLER_NOEC(thdlr189, 189)
f0101946:	6a 00                	push   $0x0
f0101948:	68 bd 00 00 00       	push   $0xbd
f010194d:	e9 fd 02 00 00       	jmp    f0101c4f <_alltraps>

f0101952 <thdlr190>:
TRAPHANDLER_NOEC(thdlr190, 190)
f0101952:	6a 00                	push   $0x0
f0101954:	68 be 00 00 00       	push   $0xbe
f0101959:	e9 f1 02 00 00       	jmp    f0101c4f <_alltraps>

f010195e <thdlr191>:
TRAPHANDLER_NOEC(thdlr191, 191)
f010195e:	6a 00                	push   $0x0
f0101960:	68 bf 00 00 00       	push   $0xbf
f0101965:	e9 e5 02 00 00       	jmp    f0101c4f <_alltraps>

f010196a <thdlr192>:
TRAPHANDLER_NOEC(thdlr192, 192)
f010196a:	6a 00                	push   $0x0
f010196c:	68 c0 00 00 00       	push   $0xc0
f0101971:	e9 d9 02 00 00       	jmp    f0101c4f <_alltraps>

f0101976 <thdlr193>:
TRAPHANDLER_NOEC(thdlr193, 193)
f0101976:	6a 00                	push   $0x0
f0101978:	68 c1 00 00 00       	push   $0xc1
f010197d:	e9 cd 02 00 00       	jmp    f0101c4f <_alltraps>

f0101982 <thdlr194>:
TRAPHANDLER_NOEC(thdlr194, 194)
f0101982:	6a 00                	push   $0x0
f0101984:	68 c2 00 00 00       	push   $0xc2
f0101989:	e9 c1 02 00 00       	jmp    f0101c4f <_alltraps>

f010198e <thdlr195>:
TRAPHANDLER_NOEC(thdlr195, 195)
f010198e:	6a 00                	push   $0x0
f0101990:	68 c3 00 00 00       	push   $0xc3
f0101995:	e9 b5 02 00 00       	jmp    f0101c4f <_alltraps>

f010199a <thdlr196>:
TRAPHANDLER_NOEC(thdlr196, 196)
f010199a:	6a 00                	push   $0x0
f010199c:	68 c4 00 00 00       	push   $0xc4
f01019a1:	e9 a9 02 00 00       	jmp    f0101c4f <_alltraps>

f01019a6 <thdlr197>:
TRAPHANDLER_NOEC(thdlr197, 197)
f01019a6:	6a 00                	push   $0x0
f01019a8:	68 c5 00 00 00       	push   $0xc5
f01019ad:	e9 9d 02 00 00       	jmp    f0101c4f <_alltraps>

f01019b2 <thdlr198>:
TRAPHANDLER_NOEC(thdlr198, 198)
f01019b2:	6a 00                	push   $0x0
f01019b4:	68 c6 00 00 00       	push   $0xc6
f01019b9:	e9 91 02 00 00       	jmp    f0101c4f <_alltraps>

f01019be <thdlr199>:
TRAPHANDLER_NOEC(thdlr199, 199)
f01019be:	6a 00                	push   $0x0
f01019c0:	68 c7 00 00 00       	push   $0xc7
f01019c5:	e9 85 02 00 00       	jmp    f0101c4f <_alltraps>

f01019ca <thdlr200>:
TRAPHANDLER_NOEC(thdlr200, 200)
f01019ca:	6a 00                	push   $0x0
f01019cc:	68 c8 00 00 00       	push   $0xc8
f01019d1:	e9 79 02 00 00       	jmp    f0101c4f <_alltraps>

f01019d6 <thdlr201>:
TRAPHANDLER_NOEC(thdlr201, 201)
f01019d6:	6a 00                	push   $0x0
f01019d8:	68 c9 00 00 00       	push   $0xc9
f01019dd:	e9 6d 02 00 00       	jmp    f0101c4f <_alltraps>

f01019e2 <thdlr202>:
TRAPHANDLER_NOEC(thdlr202, 202)
f01019e2:	6a 00                	push   $0x0
f01019e4:	68 ca 00 00 00       	push   $0xca
f01019e9:	e9 61 02 00 00       	jmp    f0101c4f <_alltraps>

f01019ee <thdlr203>:
TRAPHANDLER_NOEC(thdlr203, 203)
f01019ee:	6a 00                	push   $0x0
f01019f0:	68 cb 00 00 00       	push   $0xcb
f01019f5:	e9 55 02 00 00       	jmp    f0101c4f <_alltraps>

f01019fa <thdlr204>:
TRAPHANDLER_NOEC(thdlr204, 204)
f01019fa:	6a 00                	push   $0x0
f01019fc:	68 cc 00 00 00       	push   $0xcc
f0101a01:	e9 49 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a06 <thdlr205>:
TRAPHANDLER_NOEC(thdlr205, 205)
f0101a06:	6a 00                	push   $0x0
f0101a08:	68 cd 00 00 00       	push   $0xcd
f0101a0d:	e9 3d 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a12 <thdlr206>:
TRAPHANDLER_NOEC(thdlr206, 206)
f0101a12:	6a 00                	push   $0x0
f0101a14:	68 ce 00 00 00       	push   $0xce
f0101a19:	e9 31 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a1e <thdlr207>:
TRAPHANDLER_NOEC(thdlr207, 207)
f0101a1e:	6a 00                	push   $0x0
f0101a20:	68 cf 00 00 00       	push   $0xcf
f0101a25:	e9 25 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a2a <thdlr208>:
TRAPHANDLER_NOEC(thdlr208, 208)
f0101a2a:	6a 00                	push   $0x0
f0101a2c:	68 d0 00 00 00       	push   $0xd0
f0101a31:	e9 19 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a36 <thdlr209>:
TRAPHANDLER_NOEC(thdlr209, 209)
f0101a36:	6a 00                	push   $0x0
f0101a38:	68 d1 00 00 00       	push   $0xd1
f0101a3d:	e9 0d 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a42 <thdlr210>:
TRAPHANDLER_NOEC(thdlr210, 210)
f0101a42:	6a 00                	push   $0x0
f0101a44:	68 d2 00 00 00       	push   $0xd2
f0101a49:	e9 01 02 00 00       	jmp    f0101c4f <_alltraps>

f0101a4e <thdlr211>:
TRAPHANDLER_NOEC(thdlr211, 211)
f0101a4e:	6a 00                	push   $0x0
f0101a50:	68 d3 00 00 00       	push   $0xd3
f0101a55:	e9 f5 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a5a <thdlr212>:
TRAPHANDLER_NOEC(thdlr212, 212)
f0101a5a:	6a 00                	push   $0x0
f0101a5c:	68 d4 00 00 00       	push   $0xd4
f0101a61:	e9 e9 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a66 <thdlr213>:
TRAPHANDLER_NOEC(thdlr213, 213)
f0101a66:	6a 00                	push   $0x0
f0101a68:	68 d5 00 00 00       	push   $0xd5
f0101a6d:	e9 dd 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a72 <thdlr214>:
TRAPHANDLER_NOEC(thdlr214, 214)
f0101a72:	6a 00                	push   $0x0
f0101a74:	68 d6 00 00 00       	push   $0xd6
f0101a79:	e9 d1 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a7e <thdlr215>:
TRAPHANDLER_NOEC(thdlr215, 215)
f0101a7e:	6a 00                	push   $0x0
f0101a80:	68 d7 00 00 00       	push   $0xd7
f0101a85:	e9 c5 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a8a <thdlr216>:
TRAPHANDLER_NOEC(thdlr216, 216)
f0101a8a:	6a 00                	push   $0x0
f0101a8c:	68 d8 00 00 00       	push   $0xd8
f0101a91:	e9 b9 01 00 00       	jmp    f0101c4f <_alltraps>

f0101a96 <thdlr217>:
TRAPHANDLER_NOEC(thdlr217, 217)
f0101a96:	6a 00                	push   $0x0
f0101a98:	68 d9 00 00 00       	push   $0xd9
f0101a9d:	e9 ad 01 00 00       	jmp    f0101c4f <_alltraps>

f0101aa2 <thdlr218>:
TRAPHANDLER_NOEC(thdlr218, 218)
f0101aa2:	6a 00                	push   $0x0
f0101aa4:	68 da 00 00 00       	push   $0xda
f0101aa9:	e9 a1 01 00 00       	jmp    f0101c4f <_alltraps>

f0101aae <thdlr219>:
TRAPHANDLER_NOEC(thdlr219, 219)
f0101aae:	6a 00                	push   $0x0
f0101ab0:	68 db 00 00 00       	push   $0xdb
f0101ab5:	e9 95 01 00 00       	jmp    f0101c4f <_alltraps>

f0101aba <thdlr220>:
TRAPHANDLER_NOEC(thdlr220, 220)
f0101aba:	6a 00                	push   $0x0
f0101abc:	68 dc 00 00 00       	push   $0xdc
f0101ac1:	e9 89 01 00 00       	jmp    f0101c4f <_alltraps>

f0101ac6 <thdlr221>:
TRAPHANDLER_NOEC(thdlr221, 221)
f0101ac6:	6a 00                	push   $0x0
f0101ac8:	68 dd 00 00 00       	push   $0xdd
f0101acd:	e9 7d 01 00 00       	jmp    f0101c4f <_alltraps>

f0101ad2 <thdlr222>:
TRAPHANDLER_NOEC(thdlr222, 222)
f0101ad2:	6a 00                	push   $0x0
f0101ad4:	68 de 00 00 00       	push   $0xde
f0101ad9:	e9 71 01 00 00       	jmp    f0101c4f <_alltraps>

f0101ade <thdlr223>:
TRAPHANDLER_NOEC(thdlr223, 223)
f0101ade:	6a 00                	push   $0x0
f0101ae0:	68 df 00 00 00       	push   $0xdf
f0101ae5:	e9 65 01 00 00       	jmp    f0101c4f <_alltraps>

f0101aea <thdlr224>:
TRAPHANDLER_NOEC(thdlr224, 224)
f0101aea:	6a 00                	push   $0x0
f0101aec:	68 e0 00 00 00       	push   $0xe0
f0101af1:	e9 59 01 00 00       	jmp    f0101c4f <_alltraps>

f0101af6 <thdlr225>:
TRAPHANDLER_NOEC(thdlr225, 225)
f0101af6:	6a 00                	push   $0x0
f0101af8:	68 e1 00 00 00       	push   $0xe1
f0101afd:	e9 4d 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b02 <thdlr226>:
TRAPHANDLER_NOEC(thdlr226, 226)
f0101b02:	6a 00                	push   $0x0
f0101b04:	68 e2 00 00 00       	push   $0xe2
f0101b09:	e9 41 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b0e <thdlr227>:
TRAPHANDLER_NOEC(thdlr227, 227)
f0101b0e:	6a 00                	push   $0x0
f0101b10:	68 e3 00 00 00       	push   $0xe3
f0101b15:	e9 35 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b1a <thdlr228>:
TRAPHANDLER_NOEC(thdlr228, 228)
f0101b1a:	6a 00                	push   $0x0
f0101b1c:	68 e4 00 00 00       	push   $0xe4
f0101b21:	e9 29 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b26 <thdlr229>:
TRAPHANDLER_NOEC(thdlr229, 229)
f0101b26:	6a 00                	push   $0x0
f0101b28:	68 e5 00 00 00       	push   $0xe5
f0101b2d:	e9 1d 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b32 <thdlr230>:
TRAPHANDLER_NOEC(thdlr230, 230)
f0101b32:	6a 00                	push   $0x0
f0101b34:	68 e6 00 00 00       	push   $0xe6
f0101b39:	e9 11 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b3e <thdlr231>:
TRAPHANDLER_NOEC(thdlr231, 231)
f0101b3e:	6a 00                	push   $0x0
f0101b40:	68 e7 00 00 00       	push   $0xe7
f0101b45:	e9 05 01 00 00       	jmp    f0101c4f <_alltraps>

f0101b4a <thdlr232>:
TRAPHANDLER_NOEC(thdlr232, 232)
f0101b4a:	6a 00                	push   $0x0
f0101b4c:	68 e8 00 00 00       	push   $0xe8
f0101b51:	e9 f9 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b56 <thdlr233>:
TRAPHANDLER_NOEC(thdlr233, 233)
f0101b56:	6a 00                	push   $0x0
f0101b58:	68 e9 00 00 00       	push   $0xe9
f0101b5d:	e9 ed 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b62 <thdlr234>:
TRAPHANDLER_NOEC(thdlr234, 234)
f0101b62:	6a 00                	push   $0x0
f0101b64:	68 ea 00 00 00       	push   $0xea
f0101b69:	e9 e1 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b6e <thdlr235>:
TRAPHANDLER_NOEC(thdlr235, 235)
f0101b6e:	6a 00                	push   $0x0
f0101b70:	68 eb 00 00 00       	push   $0xeb
f0101b75:	e9 d5 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b7a <thdlr236>:
TRAPHANDLER_NOEC(thdlr236, 236)
f0101b7a:	6a 00                	push   $0x0
f0101b7c:	68 ec 00 00 00       	push   $0xec
f0101b81:	e9 c9 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b86 <thdlr237>:
TRAPHANDLER_NOEC(thdlr237, 237)
f0101b86:	6a 00                	push   $0x0
f0101b88:	68 ed 00 00 00       	push   $0xed
f0101b8d:	e9 bd 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b92 <thdlr238>:
TRAPHANDLER_NOEC(thdlr238, 238)
f0101b92:	6a 00                	push   $0x0
f0101b94:	68 ee 00 00 00       	push   $0xee
f0101b99:	e9 b1 00 00 00       	jmp    f0101c4f <_alltraps>

f0101b9e <thdlr239>:
TRAPHANDLER_NOEC(thdlr239, 239)
f0101b9e:	6a 00                	push   $0x0
f0101ba0:	68 ef 00 00 00       	push   $0xef
f0101ba5:	e9 a5 00 00 00       	jmp    f0101c4f <_alltraps>

f0101baa <thdlr240>:
TRAPHANDLER_NOEC(thdlr240, 240)
f0101baa:	6a 00                	push   $0x0
f0101bac:	68 f0 00 00 00       	push   $0xf0
f0101bb1:	e9 99 00 00 00       	jmp    f0101c4f <_alltraps>

f0101bb6 <thdlr241>:
TRAPHANDLER_NOEC(thdlr241, 241)
f0101bb6:	6a 00                	push   $0x0
f0101bb8:	68 f1 00 00 00       	push   $0xf1
f0101bbd:	e9 8d 00 00 00       	jmp    f0101c4f <_alltraps>

f0101bc2 <thdlr242>:
TRAPHANDLER_NOEC(thdlr242, 242)
f0101bc2:	6a 00                	push   $0x0
f0101bc4:	68 f2 00 00 00       	push   $0xf2
f0101bc9:	e9 81 00 00 00       	jmp    f0101c4f <_alltraps>

f0101bce <thdlr243>:
TRAPHANDLER_NOEC(thdlr243, 243)
f0101bce:	6a 00                	push   $0x0
f0101bd0:	68 f3 00 00 00       	push   $0xf3
f0101bd5:	eb 78                	jmp    f0101c4f <_alltraps>
f0101bd7:	90                   	nop

f0101bd8 <thdlr244>:
TRAPHANDLER_NOEC(thdlr244, 244)
f0101bd8:	6a 00                	push   $0x0
f0101bda:	68 f4 00 00 00       	push   $0xf4
f0101bdf:	eb 6e                	jmp    f0101c4f <_alltraps>
f0101be1:	90                   	nop

f0101be2 <thdlr245>:
TRAPHANDLER_NOEC(thdlr245, 245)
f0101be2:	6a 00                	push   $0x0
f0101be4:	68 f5 00 00 00       	push   $0xf5
f0101be9:	eb 64                	jmp    f0101c4f <_alltraps>
f0101beb:	90                   	nop

f0101bec <thdlr246>:
TRAPHANDLER_NOEC(thdlr246, 246)
f0101bec:	6a 00                	push   $0x0
f0101bee:	68 f6 00 00 00       	push   $0xf6
f0101bf3:	eb 5a                	jmp    f0101c4f <_alltraps>
f0101bf5:	90                   	nop

f0101bf6 <thdlr247>:
TRAPHANDLER_NOEC(thdlr247, 247)
f0101bf6:	6a 00                	push   $0x0
f0101bf8:	68 f7 00 00 00       	push   $0xf7
f0101bfd:	eb 50                	jmp    f0101c4f <_alltraps>
f0101bff:	90                   	nop

f0101c00 <thdlr248>:
TRAPHANDLER_NOEC(thdlr248, 248)
f0101c00:	6a 00                	push   $0x0
f0101c02:	68 f8 00 00 00       	push   $0xf8
f0101c07:	eb 46                	jmp    f0101c4f <_alltraps>
f0101c09:	90                   	nop

f0101c0a <thdlr249>:
TRAPHANDLER_NOEC(thdlr249, 249)
f0101c0a:	6a 00                	push   $0x0
f0101c0c:	68 f9 00 00 00       	push   $0xf9
f0101c11:	eb 3c                	jmp    f0101c4f <_alltraps>
f0101c13:	90                   	nop

f0101c14 <thdlr250>:
TRAPHANDLER_NOEC(thdlr250, 250)
f0101c14:	6a 00                	push   $0x0
f0101c16:	68 fa 00 00 00       	push   $0xfa
f0101c1b:	eb 32                	jmp    f0101c4f <_alltraps>
f0101c1d:	90                   	nop

f0101c1e <thdlr251>:
TRAPHANDLER_NOEC(thdlr251, 251)
f0101c1e:	6a 00                	push   $0x0
f0101c20:	68 fb 00 00 00       	push   $0xfb
f0101c25:	eb 28                	jmp    f0101c4f <_alltraps>
f0101c27:	90                   	nop

f0101c28 <thdlr252>:
TRAPHANDLER_NOEC(thdlr252, 252)
f0101c28:	6a 00                	push   $0x0
f0101c2a:	68 fc 00 00 00       	push   $0xfc
f0101c2f:	eb 1e                	jmp    f0101c4f <_alltraps>
f0101c31:	90                   	nop

f0101c32 <thdlr253>:
TRAPHANDLER_NOEC(thdlr253, 253)
f0101c32:	6a 00                	push   $0x0
f0101c34:	68 fd 00 00 00       	push   $0xfd
f0101c39:	eb 14                	jmp    f0101c4f <_alltraps>
f0101c3b:	90                   	nop

f0101c3c <thdlr254>:
TRAPHANDLER_NOEC(thdlr254, 254)
f0101c3c:	6a 00                	push   $0x0
f0101c3e:	68 fe 00 00 00       	push   $0xfe
f0101c43:	eb 0a                	jmp    f0101c4f <_alltraps>
f0101c45:	90                   	nop

f0101c46 <thdlr255>:
TRAPHANDLER_NOEC(thdlr255, 255)
f0101c46:	6a 00                	push   $0x0
f0101c48:	68 ff 00 00 00       	push   $0xff
f0101c4d:	eb 00                	jmp    f0101c4f <_alltraps>

f0101c4f <_alltraps>:
 * Lab 3: Your code here for _alltraps
 */

.globl _alltraps
_alltraps:
	pushl %ds
f0101c4f:	1e                   	push   %ds
        pushl %es
f0101c50:	06                   	push   %es
	pushal
f0101c51:	60                   	pusha  

	movw $GD_KD, %ax
f0101c52:	66 b8 10 00          	mov    $0x10,%ax
	movw %ax, %ds
f0101c56:	8e d8                	mov    %eax,%ds
	movw %ax, %es
f0101c58:	8e c0                	mov    %eax,%es

        pushl %esp  /* trap(%esp) */
f0101c5a:	54                   	push   %esp
        call trap
f0101c5b:	e8 fe f2 ff ff       	call   f0100f5e <trap>

	addl $4, %esp
f0101c60:	83 c4 04             	add    $0x4,%esp
	popal
f0101c63:	61                   	popa   
	pop %es
f0101c64:	07                   	pop    %es
	pop %ds
f0101c65:	1f                   	pop    %ds
	addl $8, %esp # trap num and errcode
f0101c66:	83 c4 08             	add    $0x8,%esp
	iret
f0101c69:	cf                   	iret   

f0101c6a <itoa>:
#include <inc/stdarg.h>
#include <inc/syscall.h>

// extern void sys_crash() __attribute__((noreturn));

char *itoa(int a) {
f0101c6a:	55                   	push   %ebp
f0101c6b:	89 e5                	mov    %esp,%ebp
f0101c6d:	83 ec 10             	sub    $0x10,%esp
	static char buf[30];
	char *p = buf + sizeof(buf) - 1;
f0101c70:	c7 45 fc 5d c9 12 f0 	movl   $0xf012c95d,-0x4(%ebp)
	do {
		*--p = '0' + a % 10;
f0101c77:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
f0101c7b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0101c7e:	ba 67 66 66 66       	mov    $0x66666667,%edx
f0101c83:	89 c8                	mov    %ecx,%eax
f0101c85:	f7 ea                	imul   %edx
f0101c87:	c1 fa 02             	sar    $0x2,%edx
f0101c8a:	89 c8                	mov    %ecx,%eax
f0101c8c:	c1 f8 1f             	sar    $0x1f,%eax
f0101c8f:	29 c2                	sub    %eax,%edx
f0101c91:	89 d0                	mov    %edx,%eax
f0101c93:	c1 e0 02             	shl    $0x2,%eax
f0101c96:	01 d0                	add    %edx,%eax
f0101c98:	01 c0                	add    %eax,%eax
f0101c9a:	29 c1                	sub    %eax,%ecx
f0101c9c:	89 ca                	mov    %ecx,%edx
f0101c9e:	89 d0                	mov    %edx,%eax
f0101ca0:	83 c0 30             	add    $0x30,%eax
f0101ca3:	89 c2                	mov    %eax,%edx
f0101ca5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101ca8:	88 10                	mov    %dl,(%eax)
	} while (a /= 10);
f0101caa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0101cad:	ba 67 66 66 66       	mov    $0x66666667,%edx
f0101cb2:	89 c8                	mov    %ecx,%eax
f0101cb4:	f7 ea                	imul   %edx
f0101cb6:	c1 fa 02             	sar    $0x2,%edx
f0101cb9:	89 c8                	mov    %ecx,%eax
f0101cbb:	c1 f8 1f             	sar    $0x1f,%eax
f0101cbe:	29 c2                	sub    %eax,%edx
f0101cc0:	89 d0                	mov    %edx,%eax
f0101cc2:	89 45 08             	mov    %eax,0x8(%ebp)
f0101cc5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101cc9:	75 ac                	jne    f0101c77 <itoa+0xd>
	return p;
f0101ccb:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0101cce:	c9                   	leave  
f0101ccf:	c3                   	ret    

f0101cd0 <memcpy>:

void memcpy(void *dest, const void *src, size_t size) {
f0101cd0:	55                   	push   %ebp
f0101cd1:	89 e5                	mov    %esp,%ebp
f0101cd3:	57                   	push   %edi
f0101cd4:	56                   	push   %esi
f0101cd5:	53                   	push   %ebx
	asm volatile ("cld; rep movsb" : : "c"(size), "S"(src), "D"(dest));
f0101cd6:	8b 45 10             	mov    0x10(%ebp),%eax
f0101cd9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0101cdc:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0101cdf:	89 c1                	mov    %eax,%ecx
f0101ce1:	89 d6                	mov    %edx,%esi
f0101ce3:	89 df                	mov    %ebx,%edi
f0101ce5:	fc                   	cld    
f0101ce6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
}
f0101ce8:	90                   	nop
f0101ce9:	5b                   	pop    %ebx
f0101cea:	5e                   	pop    %esi
f0101ceb:	5f                   	pop    %edi
f0101cec:	5d                   	pop    %ebp
f0101ced:	c3                   	ret    

f0101cee <memset>:

void memset(void *dest, int data, size_t size) {
f0101cee:	55                   	push   %ebp
f0101cef:	89 e5                	mov    %esp,%ebp
f0101cf1:	57                   	push   %edi
f0101cf2:	53                   	push   %ebx
	asm volatile ("cld; rep stosb" : : "c"(size), "a"(data), "D"(dest));
f0101cf3:	8b 55 10             	mov    0x10(%ebp),%edx
f0101cf6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101cf9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0101cfc:	89 d1                	mov    %edx,%ecx
f0101cfe:	89 df                	mov    %ebx,%edi
f0101d00:	fc                   	cld    
f0101d01:	f3 aa                	rep stos %al,%es:(%edi)
}
f0101d03:	90                   	nop
f0101d04:	5b                   	pop    %ebx
f0101d05:	5f                   	pop    %edi
f0101d06:	5d                   	pop    %ebp
f0101d07:	c3                   	ret    

f0101d08 <strlen>:

size_t strlen(const char *str) {
f0101d08:	55                   	push   %ebp
f0101d09:	89 e5                	mov    %esp,%ebp
f0101d0b:	83 ec 10             	sub    $0x10,%esp
	int len = 0;
f0101d0e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while (*str ++) len ++;
f0101d15:	eb 04                	jmp    f0101d1b <strlen+0x13>
f0101d17:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
f0101d1b:	8b 45 08             	mov    0x8(%ebp),%eax
f0101d1e:	8d 50 01             	lea    0x1(%eax),%edx
f0101d21:	89 55 08             	mov    %edx,0x8(%ebp)
f0101d24:	0f b6 00             	movzbl (%eax),%eax
f0101d27:	84 c0                	test   %al,%al
f0101d29:	75 ec                	jne    f0101d17 <strlen+0xf>
	return len;
f0101d2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0101d2e:	c9                   	leave  
f0101d2f:	c3                   	ret    

f0101d30 <strcpy>:

void strcpy(char *d, const char *s) {
f0101d30:	55                   	push   %ebp
f0101d31:	89 e5                	mov    %esp,%ebp
	memcpy(d, s, strlen(s) + 1);
f0101d33:	ff 75 0c             	pushl  0xc(%ebp)
f0101d36:	e8 cd ff ff ff       	call   f0101d08 <strlen>
f0101d3b:	83 c4 04             	add    $0x4,%esp
f0101d3e:	83 c0 01             	add    $0x1,%eax
f0101d41:	50                   	push   %eax
f0101d42:	ff 75 0c             	pushl  0xc(%ebp)
f0101d45:	ff 75 08             	pushl  0x8(%ebp)
f0101d48:	e8 83 ff ff ff       	call   f0101cd0 <memcpy>
f0101d4d:	83 c4 0c             	add    $0xc,%esp
}
f0101d50:	90                   	nop
f0101d51:	c9                   	leave  
f0101d52:	c3                   	ret    

f0101d53 <_warn>:

void _warn(const char* file, int line, const char* format, ...) {
f0101d53:	55                   	push   %ebp
f0101d54:	89 e5                	mov    %esp,%ebp
f0101d56:	83 ec 18             	sub    $0x18,%esp
	printk("Warning (%s:%d): ", file, line);
f0101d59:	83 ec 04             	sub    $0x4,%esp
f0101d5c:	ff 75 0c             	pushl  0xc(%ebp)
f0101d5f:	ff 75 08             	pushl  0x8(%ebp)
f0101d62:	68 e1 20 10 f0       	push   $0xf01020e1
f0101d67:	e8 a9 eb ff ff       	call   f0100915 <printk>
f0101d6c:	83 c4 10             	add    $0x10,%esp
	va_list args;
	va_start(args, format);
f0101d6f:	8d 45 14             	lea    0x14(%ebp),%eax
f0101d72:	89 45 f4             	mov    %eax,-0xc(%ebp)
	printk(format, args);
f0101d75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101d78:	83 ec 08             	sub    $0x8,%esp
f0101d7b:	50                   	push   %eax
f0101d7c:	ff 75 10             	pushl  0x10(%ebp)
f0101d7f:	e8 91 eb ff ff       	call   f0100915 <printk>
f0101d84:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	printk("\n");
f0101d87:	83 ec 0c             	sub    $0xc,%esp
f0101d8a:	68 f3 20 10 f0       	push   $0xf01020f3
f0101d8f:	e8 81 eb ff ff       	call   f0100915 <printk>
f0101d94:	83 c4 10             	add    $0x10,%esp
}
f0101d97:	90                   	nop
f0101d98:	c9                   	leave  
f0101d99:	c3                   	ret    

f0101d9a <_panic>:

void _panic(const char* file, int line, const char* format, ...) {
f0101d9a:	55                   	push   %ebp
f0101d9b:	89 e5                	mov    %esp,%ebp
f0101d9d:	83 ec 18             	sub    $0x18,%esp
	__asm __volatile("cld");
f0101da0:	fc                   	cld    
	printk("Fatal (%s:%d): ", file, line);
f0101da1:	83 ec 04             	sub    $0x4,%esp
f0101da4:	ff 75 0c             	pushl  0xc(%ebp)
f0101da7:	ff 75 08             	pushl  0x8(%ebp)
f0101daa:	68 f5 20 10 f0       	push   $0xf01020f5
f0101daf:	e8 61 eb ff ff       	call   f0100915 <printk>
f0101db4:	83 c4 10             	add    $0x10,%esp
	va_list args;
	va_start(args, format);
f0101db7:	8d 45 14             	lea    0x14(%ebp),%eax
f0101dba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	printk(format, args);
f0101dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101dc0:	83 ec 08             	sub    $0x8,%esp
f0101dc3:	50                   	push   %eax
f0101dc4:	ff 75 10             	pushl  0x10(%ebp)
f0101dc7:	e8 49 eb ff ff       	call   f0100915 <printk>
f0101dcc:	83 c4 10             	add    $0x10,%esp
	va_end(args);
	printk("\n");
f0101dcf:	83 ec 0c             	sub    $0xc,%esp
f0101dd2:	68 f3 20 10 f0       	push   $0xf01020f3
f0101dd7:	e8 39 eb ff ff       	call   f0100915 <printk>
f0101ddc:	83 c4 10             	add    $0x10,%esp
	sys_crash();
f0101ddf:	e8 3a ed ff ff       	call   f0100b1e <sys_crash>
